00 - bind framebuffer
00 - bind program
00 - bind vertex array
00 - blockWrites
00 - setBackfaceCulling
00 - setFrontFace
00 - setStencil
00 - setDrawId
00 - clear commands
00 - clear commands, partial framebuffer
00 - clear multiple framebuffers
00 - user
00 - drawID_no_program

  TEST SELHAL!

  Tento test zkou≈°√≠, zda kresl√≠c√≠ p≈ô√≠kazy maj√≠ spr√°vn√© gl_DrawID.
  P≈ô√≠kaz student_GPU_run je v tomto testu zavol√°n nƒõkolikr√°t.
  P≈ôi ka≈æd√©m zavol√°n√≠ by se mƒõlo gl_DrawID nastavit zpƒõt na 0.
  

  ==========================
  === DETAILN√ç INFORMACE ===
  ==========================
  
  Command buffer v tomto testu vypad√° takto:
  
[1;90m  CommandBuffer::nofCommands = 3
  CommandBuffer::commands = {
    0:
      Command::type = DRAW                        
      DrawCommand::nofVertices = 3
    1:
      Command::type = DRAW                        
      DrawCommand::nofVertices = 3
    2:
      Command::type = DRAW                        
      DrawCommand::nofVertices = 3
  }
[0m
  Jak se li≈°√≠ va≈°e zmƒõny nad pamƒõt√≠ od tƒõch, co se mƒõly prov√©st:
  
mem.gl_DrawID = 6;//va≈°e    
mem.gl_DrawID = 3;//mƒõlo b√Ωt


  Jak√© zmƒõny jste nad pamƒõt√≠ provedli vy:
[1;90m  GPUMemory::gl_DrawID            = 6
[0m
  Jak√© zmƒõny se nad pamƒõt√≠ mƒõly prov√©st:
[1;90m  GPUMemory::gl_DrawID            = 3
[0m
  Jak√© zmƒõny byly nad pamƒõt√≠ provedeny je≈°tƒõ p≈ôed spu≈°tƒõn√≠m:
[1;90m  Poƒç√°teƒçn√≠ pamƒõt byla nastavena defaultnƒõ
[0m00 - sub command tests
00 - vertex shader, gl_VertexID (no indexing)
00 - drawID_empty_program
00 - mixed clear and draw commands
00 - vertex shader, shader interface
00 - vertex shader, gl_VertexID (indexing)
  (32bit indexing)
  (16bit indexing)
  (8bit indexing)
00 - vertex shader, attributes
  (offset=0,stride=4)
  (offset=12,stride=4)
  (offset=0,stride=16)
  (offset=8,stride=16)
00 - vertex shader, attributes, offset, stride, multiple buffers
00 - vertex shader, attributes, offset, stride, indexing
00 - Raterization: basic rasterization to check primitive assembly unit and viewport transformation
  raster test: 0 - ok.
00 - Rasterization: out of window tests
  raster test: 0 - ok.
  raster test: 1 - ok.
  raster test: 2 - ok.
  raster test: 3 - ok.
  raster test: 4 - ok.
  raster test: 5 - ok.
00 - rasterization should produce correct number of fragments
  raster test: 0 - ok.
  raster test: 1 - ok.
  raster test: 2 - ok.
  raster test: 3 - ok.
  raster test: 4 - ok.
  raster test: 5 - ok.
  raster test: 6 - ok.
  raster test: 7 - ok.
  raster test: 8 - ok.
  raster test: 9 - ok.
  raster test: 10 - ok.
  raster test: 11 - ok.
  raster test: 12 - ok.
  raster test: 13 - ok.
  raster test: 14 - ok.
  raster test: 15 - ok.
  raster test: 16 - ok.
  raster test: 17 - ok.
  raster test: 18 - ok.
  raster test: 19 - ok.
  raster test: 20 - ok.
  raster test: 21 - ok.
  raster test: 22 - ok.
  raster test: 23 - ok.
  raster test: 24 - ok.
  raster test: 25 - ok.
  raster test: 26 - ok.
  raster test: 27 - ok.
  raster test: 28 - ok.
  raster test: 29 - ok.
  raster test: 30 - ok.
  raster test: 31 - ok.
  raster test: 32 - ok.
  raster test: 33 - ok.
  raster test: 34 - ok.
  raster test: 35 - ok.
  raster test: 36 - ok.
  raster test: 37 - ok.
  raster test: 38 - ok.
  raster test: 39 - ok.
  raster test: 40 - ok.
  raster test: 41 - ok.
  raster test: 42 - ok.
  raster test: 43 - ok.
  raster test: 44 - ok.
  raster test: 45 - ok.
  raster test: 46 - ok.
  raster test: 47 - ok.
  raster test: 48 - ok.
  raster test: 49 - ok.
  raster test: 50 - ok.
  raster test: 51 - ok.
  raster test: 52 - ok.
  raster test: 53 - ok.
  raster test: 54 - ok.
  raster test: 55 - ok.
  raster test: 56 - ok.
  raster test: 57 - ok.
  raster test: 58 - ok.
  raster test: 59 - ok.
  raster test: 60 - ok.
  raster test: 61 - ok.
  raster test: 62 - ok.
  raster test: 63 - ok.
  raster test: 64 - ok.
  raster test: 65 - ok.
  raster test: 66 - ok.
  raster test: 67 - ok.
  raster test: 68 - ok.
  raster test: 69 - ok.
  raster test: 70 - ok.
  raster test: 71 - ok.
  raster test: 72 - ok.
  raster test: 73 - ok.
  raster test: 74 - ok.
  raster test: 75 - ok.
  raster test: 76 - ok.
  raster test: 77 - ok.
  raster test: 78 - ok.
  raster test: 79 - ok.
  raster test: 80 - ok.
  raster test: 81 - ok.
  raster test: 82 - ok.
  raster test: 83 - ok.
  raster test: 84 - ok.
  raster test: 85 - ok.
  raster test: 86 - ok.
  raster test: 87 - ok.
  raster test: 88 - ok.
  raster test: 89 - ok.
  raster test: 90 - ok.
  raster test: 91 - ok.
  raster test: 92 - ok.
  raster test: 93 - ok.
  raster test: 94 - ok.
  raster test: 95 - ok.
  raster test: 96 - ok.
  raster test: 97 - ok.
  raster test: 98 - ok.
  raster test: 99 - ok.
  raster test: 100 - ok.
  raster test: 101 - ok.
  raster test: 102 - ok.
  raster test: 103 - ok.
  raster test: 104 - ok.
  raster test: 105 - ok.
  raster test: 106 - ok.
  raster test: 107 - ok.
  raster test: 108 - ok.
  raster test: 109 - ok.
  raster test: 110 - ok.
  raster test: 111 - ok.
  raster test: 112 - ok.
  raster test: 113 - ok.
  raster test: 114 - ok.
  raster test: 115 - ok.
  raster test: 116 - ok.
  raster test: 117 - ok.
  raster test: 118 - ok.
  raster test: 119 - ok.
  raster test: 120 - ok.
  raster test: 121 - ok.
  raster test: 122 - ok.
  raster test: 123 - ok.
  raster test: 124 - ok.
  raster test: 125 - ok.
  raster test: 126 - ok.
  raster test: 127 - ok.
  raster test: 128 - ok.
  raster test: 129 - ok.
  raster test: 130 - ok.
  raster test: 131 - ok.
  raster test: 132 - ok.
  raster test: 133 - ok.
  raster test: 134 - ok.
  raster test: 135 - ok.
  raster test: 136 - ok.
  raster test: 137 - ok.
  raster test: 138 - ok.
  raster test: 139 - ok.
  raster test: 140 - ok.
  raster test: 141 - ok.
  raster test: 142 - ok.
  raster test: 143 - ok.
  raster test: 144 - ok.
  raster test: 145 - ok.
  raster test: 146 - ok.
  raster test: 147 - ok.
  raster test: 148 - ok.
  raster test: 149 - ok.
  raster test: 150 - ok.
  raster test: 151 - ok.
  raster test: 152 - ok.
  raster test: 153 - ok.
  raster test: 154 - ok.
  raster test: 155 - ok.
  raster test: 156 - ok.
  raster test: 157 - ok.
  raster test: 158 - ok.
  raster test: 159 - ok.
  raster test: 160 - ok.
  raster test: 161 - ok.
  raster test: 162 - ok.
  raster test: 163 - ok.
  raster test: 164 - ok.
  raster test: 165 - ok.
  raster test: 166 - ok.
  raster test: 167 - ok.
  raster test: 168 - ok.
  raster test: 169 - ok.
  raster test: 170 - ok.
  raster test: 171 - ok.
  raster test: 172 - ok.
  raster test: 173 - ok.
  raster test: 174 - ok.
  raster test: 175 - ok.
  raster test: 176 - ok.
  raster test: 177 - ok.
  raster test: 178 - ok.
  raster test: 179 - ok.
  raster test: 180 - ok.
  raster test: 181 - ok.
  raster test: 182 - ok.
  raster test: 183 - ok.
  raster test: 184 - ok.
  raster test: 185 - ok.
  raster test: 186 - ok.
  raster test: 187 - ok.
  raster test: 188 - ok.
  raster test: 189 - ok.
  raster test: 190 - ok.
  raster test: 191 - ok.
  raster test: 192 - ok.
  raster test: 193 - ok.
  raster test: 194 - ok.
  raster test: 195 - ok.
  raster test: 196 - ok.
  raster test: 197 - ok.
  raster test: 198 - ok.
  raster test: 199 - ok.
  raster test: 200 - ok.
  raster test: 201 - ok.
  raster test: 202 - ok.
  raster test: 203 - ok.
  raster test: 204 - ok.
  raster test: 205 - ok.
  raster test: 206 - ok.
  raster test: 207 - ok.
  raster test: 208 - ok.
  raster test: 209 - ok.
  raster test: 210 - ok.
  raster test: 211 - ok.
  raster test: 212 - ok.
  raster test: 213 - ok.
  raster test: 214 - ok.
  raster test: 215 - ok.
  raster test: 216 - ok.
  raster test: 217 - ok.
  raster test: 218 - ok.
  raster test: 219 - ok.
  raster test: 220 - ok.
  raster test: 221 - ok.
  raster test: 222 - ok.
  raster test: 223 - ok.
  raster test: 224 - ok.
  raster test: 225 - ok.
  raster test: 226 - ok.
  raster test: 227 - ok.
  raster test: 228 - ok.
  raster test: 229 - ok.
  raster test: 230 - ok.
  raster test: 231 - ok.
  raster test: 232 - ok.
  raster test: 233 - ok.
  raster test: 234 - ok.
  raster test: 235 - ok.
  raster test: 236 - ok.
  raster test: 237 - ok.
  raster test: 238 - ok.
  raster test: 239 - ok.
  raster test: 240 - ok.
  raster test: 241 - ok.
  raster test: 242 - ok.
  raster test: 243 - ok.
  raster test: 244 - ok.
  raster test: 245 - ok.
  raster test: 246 - ok.
  raster test: 247 - ok.
  raster test: 248 - ok.
  raster test: 249 - ok.
  raster test: 250 - ok.
  raster test: 251 - ok.
  raster test: 252 - ok.
  raster test: 253 - ok.
  raster test: 254 - ok.
  raster test: 255 - ok.
  raster test: 256 - ok.
  raster test: 257 - ok.
  raster test: 258 - ok.
  raster test: 259 - ok.
  raster test: 260 - ok.
  raster test: 261 - ok.
  raster test: 262 - ok.
  raster test: 263 - ok.
  raster test: 264 - ok.
  raster test: 265 - ok.
  raster test: 266 - ok.
  raster test: 267 - ok.
  raster test: 268 - ok.
  raster test: 269 - ok.
  raster test: 270 - ok.
  raster test: 271 - ok.
  raster test: 272 - ok.
  raster test: 273 - ok.
  raster test: 274 - ok.
  raster test: 275 - ok.
  raster test: 276 - ok.
  raster test: 277 - ok.
  raster test: 278 - ok.
  raster test: 279 - ok.
  raster test: 280 - ok.
  raster test: 281 - ok.
  raster test: 282 - ok.
  raster test: 283 - ok.
  raster test: 284 - ok.
  raster test: 285 - ok.
  raster test: 286 - ok.
  raster test: 287 - ok.
  raster test: 288 - ok.
  raster test: 289 - ok.
  raster test: 290 - ok.
  raster test: 291 - ok.
  raster test: 292 - ok.
  raster test: 293 - ok.
  raster test: 294 - ok.
  raster test: 295 - ok.
  raster test: 296 - ok.
  raster test: 297 - ok.
  raster test: 298 - ok.
  raster test: 299 - ok.
  raster test: 300 - ok.
  raster test: 301 - ok.
  raster test: 302 - ok.
  raster test: 303 - ok.
  raster test: 304 - ok.
  raster test: 305 - ok.
  raster test: 306 - ok.
  raster test: 307 - ok.
  raster test: 308 - ok.
  raster test: 309 - ok.
  raster test: 310 - ok.
  raster test: 311 - ok.
00 - Rasterization: perspective division
  raster test: 0 - ok.
00 - Rasterization: backface culling tests
  raster test: 0 - ok.
  raster test: 1 - ok.
  raster test: 2 - ok.
  raster test: 3 - ok.
  raster test: 4 - ok.
  raster test: 5 - ok.
  raster test: 6 - ok.
  raster test: 7 - ok.
00 - depth interpolation
  raster test: 0 - ok.
00 - vertex attributes interpolated to fragment attributes
  raster test: 0 - ok.
00 - perspective correct interpolation of vertex attributes to fragment attributes
  raster test: 0 - ok.
00 - All Stencil Tests and stencil operations invert on sfail
  raster test: 0 - ok.
  raster test: 1 - ok.
  raster test: 2 - ok.
  raster test: 3 - ok.
  raster test: 4 - ok.
  raster test: 5 - ok.
  raster test: 6 - ok.
  raster test: 7 - ok.
  raster test: 8 - ok.
  raster test: 9 - ok.
  raster test: 10 - ok.
  raster test: 11 - ok.
  raster test: 12 - ok.
  raster test: 13 - ok.
  raster test: 14 - ok.
  raster test: 15 - ok.
  raster test: 16 - ok.
  raster test: 17 - ok.
  raster test: 18 - ok.
  raster test: 19 - ok.
  raster test: 20 - ok.
  raster test: 21 - ok.
  raster test: 22 - ok.
  raster test: 23 - ok.

  Tento test kontroluje, zda spr√°vnƒõ funguje rastrov√° ƒç√°st grafick√© karty.

  Pr√°ce nad stencilov√Ωm bufferem je komplexn√≠.
  Z√°pis do stencilov√©ho bufferu je prov√°dƒõn rasterizac√≠.
  Je nƒõkolik druh≈Ø modifikac√≠ stencilov√©ho bufferu - viz struktura StencilOp.
  Operace se m≈Ø≈æe li≈°it pro p≈ôivr√°cen√© a odvr√°cen√© strany frontOps / backOps.
  A operace se m≈Ø≈æe li≈°it podle toho, zda sel≈æe stencilov√Ω test (sfail).
  Nebo zda sel≈æe depth test (dpfail).
  Nebo zda v≈°echny testy projdou (dppass).

  
  Nƒõco je ≈°patnƒõ...
  CHYBA! Rastrov√° ƒç√°st GPU nefunguje spr√°vnƒõ!
Raterizuje se troj√∫heln√≠k: A=(-1,-1,0,1)B=(-1,1,0,1)C=(1,-1,0,1)
P≈ôi rozli≈°en√≠: (10,10)

    Co≈æ odpov√≠d√° rasterizaci troj√∫heln√≠k≈Ø v NDC (po perspektivn√≠m dƒõlen√≠):
    A = vec3(-1,-1,0);
    B = vec3(-1,1,0);
    C = vec3(1,-1,0);

    Co≈æ odpov√≠d√° rasterizaci troj√∫heln√≠k≈Ø ve view-space:
    A = vec3(0,0,0);
    B = vec3(0,10,0);
    C = vec3(10,0,0);
    troj√∫heln√≠k je CW
Barevn√Ω    buffer: nen√≠
Hloubkov√Ω  buffer: nen√≠
Stencilov√Ω buffer byl inicializov√°n na: 0
Nastaven√≠ stencilu: 
StencilSettings::enabled         = true
StencilSettings::refValue        = 0
StencilSettings::func            = NEVER   
Stencilsettings::backOps.sfail   = INVERT   
Stencilsettings::backOps.dpfail  = KEEP     
Stencilsettings::backOps.dppass  = KEEP     
Stencilsettings::frontOps.sfail  = INVERT   
Stencilsettings::frontOps.dpfail = KEEP     
Stencilsettings::frontOps.dppass = KEEP     

    Stencil test je p≈ôed depth testem a operuje nad stencilov√Ωm bufferem.

    V OpenGL ≈ô√≠d√≠ stencilov√© operace funkce:
    glEnable(GL_STENCIL_TEST) - povoluje stencilov√Ω test a operace
    glDisable(GL_STENCIL_TEST) - povoluje stencilov√Ω test a operace
    glStencilOpSeparate - nastavuje stencilovou operaci
    glStencilFunc - nastavuje funkci stencilov√©ho testu

    https://registry.khronos.org/OpenGL-Refpages/gl4/html/glEnable.xhtml
    https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDisable.xhtml
    https://registry.khronos.org/OpenGL-Refpages/gl4/html/glStencilFunc.xhtml
    https://registry.khronos.org/OpenGL-Refpages/gl4/html/glStencilOpSeparate.xhtml
    CHYBA!

  ==========================
  === DETAILN√ç INFORMACE ===
  ==========================
  
  Command buffer v tomto testu vypad√° takto:
  
[1;90m  CommandBuffer::nofCommands = 8
  CommandBuffer::commands = {
    0:
      Command::type = CLEAR_COLOR                 
      ClearColorCommand::value = (0,0,0,0)
    1:
      Command::type = CLEAR_DEPTH                 
      ClearDepthCommand::value = 1e+11
    2:
      Command::type = CLEAR_STENCIL               
      ClearStencilCommand::value = 0
    3:
      Command::type = BLOCK_WRITES_COMMAND        
      BlockWritesCommand::blockWrites = {
        BlockWrites::color   = false
        BlockWrites::depth   = false
        BlockWrites::stencil = false
      }
    4:
      Command::type = SET_BACKFACE_CULLING_COMMAND
      SetBackfaceCullingCommand::enabled = false
    5:
      Command::type = SET_FRONT_FACE_COMMAND      
      SetFrontFaceCommand::frontFaceIsCounterClockWise = true
    6:
      Command::type = SET_STENCIL_COMMAND         
      SetStencilCommand::settings = {
        StencilSettings::enabled         = true
        StencilSettings::refValue        = 0
        StencilSettings::func            = NEVER   
        Stencilsettings::backOps.sfail   = INVERT   
        Stencilsettings::backOps.dpfail  = KEEP     
        Stencilsettings::backOps.dppass  = KEEP     
        Stencilsettings::frontOps.sfail  = INVERT   
        Stencilsettings::frontOps.dpfail = KEEP     
        Stencilsettings::frontOps.dppass = KEEP     
      }
    7:
      Command::type = DRAW                        
      DrawCommand::nofVertices = 3
  }
[0m
  Jak se li≈°√≠ va≈°e zmƒõny nad pamƒõt√≠ od tƒõch, co se mƒõly prov√©st:
  
mem.framebuffers[0].stencil.data = Image::bytesPerPixel = 1
Image::channels      = 1
Image::pitch         = 10
Image::format        = U8 
Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
Image::data[] = {ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff 00 ff ff ff ff ff ff ff ff 00 00 ff ff ff ff ff ff ff 00 00 00 ff ff ff ff ff ff 00 00 00 00 ff ff ff ff ff 00 00 00 00 00 ff ff ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00 00 00 ff ff 00 00 00 00 00 00 00 00 ff 00 00 00 00 00 00 00 00 00 
}
;//va≈°e    
mem.framebuffers[0].stencil.data = Image::bytesPerPixel = 1
Image::channels      = 1
Image::pitch         = 10
Image::format        = U8 
Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
Image::data[] = {ff ff ff ff ff ff ff ff ff 00 ff ff ff ff ff ff ff ff 00 00 ff ff ff ff ff ff ff 00 00 00 ff ff ff ff ff ff 00 00 00 00 ff ff ff ff ff 00 00 00 00 00 ff ff ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00 00 00 ff ff 00 00 00 00 00 00 00 00 ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
}
;//mƒõlo b√Ωt


  Jak√© zmƒõny jste nad pamƒõt√≠ provedli vy:
[1;90m  float vertexBuffer0[12] = {
    -1,    -1,    0,    1,    -1,    1,    0,    1,    1,    -1,    0,    1,
  };
  float vertexBuffer1[12] = {
    1,    0,    0,    1,    0,    0,    1,    1,    0,    1,    0,    1,
  };
  GPUMemory::gl_DrawID            = 1
  GPUMemory::stencilSettings = {
    StencilSettings::enabled         = true
    StencilSettings::refValue        = 0
    StencilSettings::func            = NEVER   
    Stencilsettings::backOps.sfail   = INVERT   
    Stencilsettings::backOps.dpfail  = KEEP     
    Stencilsettings::backOps.dppass  = KEEP     
    Stencilsettings::frontOps.sfail  = INVERT   
    Stencilsettings::frontOps.dpfail = KEEP     
    Stencilsettings::frontOps.dppass = KEEP     
  }
  GPUMemory::framebuffers[10] = {
    0:
      Framebuffer::width     = 10
      Framebuffer::height    = 10
      Framebuffer::yReversed = 0
      Framebuffer::color = {
        Image::bytesPerPixel = 3
        Image::channels      = 3
        Image::pitch         = 30
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
      Framebuffer::depth = {
        Image::bytesPerPixel = 4
        Image::channels      = 1
        Image::pitch         = 40
        Image::format        = F32
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
      Framebuffer::stencil = {
        Image::bytesPerPixel = 1
        Image::channels      = 1
        Image::pitch         = 10
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data[] = {ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff 00 ff ff ff ff ff ff ff ff 00 00 ff ff ff ff ff ff ff 00 00 00 ff ff ff ff ff ff 00 00 00 00 ff ff ff ff ff 00 00 00 00 00 ff ff ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00 00 00 ff ff 00 00 00 00 00 00 00 00 ff 00 00 00 00 00 00 00 00 00 
        }
      }
  }
  GPUMemory::programs[100] = {
    0:
      Program::fragmentShader = shader
      Program::vertexShader   = shader
      Program::vs2fs[0]   = VEC4 
      Program::vs2fs[1]   = EMPTY
      Program::vs2fs[2]   = EMPTY
      Program::vs2fs[3]   = EMPTY
  }
  GPUMemory::buffers[100] = {
    0:
      Buffer::data = vertexBuffer0
      Buffer::size = 48
    1:
      Buffer::data = vertexBuffer1
      Buffer::size = 48
  }
  GPUMemory::vertexArrays[10000] = {
    0:
      VertexArray::indexBufferID = -1
      VertexArray::indexOffset   = 0
      VertexArray::indexType     = U32
      VertexArray::vertexAttrib[0].bufferID = 0
      VertexArray::vertexAttrib[0].offset   = 0
      VertexArray::vertexAttrib[0].stride   = 16
      VertexArray::vertexAttrib[0].type     = VEC4 
      VertexArray::vertexAttrib[1].bufferID = 1
      VertexArray::vertexAttrib[1].offset   = 0
      VertexArray::vertexAttrib[1].stride   = 16
      VertexArray::vertexAttrib[1].type     = VEC4 
  }
[0m
  Jak√© zmƒõny se nad pamƒõt√≠ mƒõly prov√©st:
[1;90m  float vertexBuffer0[12] = {
    -1,    -1,    0,    1,    -1,    1,    0,    1,    1,    -1,    0,    1,
  };
  float vertexBuffer1[12] = {
    1,    0,    0,    1,    0,    0,    1,    1,    0,    1,    0,    1,
  };
  GPUMemory::gl_DrawID            = 1
  GPUMemory::stencilSettings = {
    StencilSettings::enabled         = true
    StencilSettings::refValue        = 0
    StencilSettings::func            = NEVER   
    Stencilsettings::backOps.sfail   = INVERT   
    Stencilsettings::backOps.dpfail  = KEEP     
    Stencilsettings::backOps.dppass  = KEEP     
    Stencilsettings::frontOps.sfail  = INVERT   
    Stencilsettings::frontOps.dpfail = KEEP     
    Stencilsettings::frontOps.dppass = KEEP     
  }
  GPUMemory::framebuffers[10] = {
    0:
      Framebuffer::width     = 10
      Framebuffer::height    = 10
      Framebuffer::yReversed = 0
      Framebuffer::color = {
        Image::bytesPerPixel = 3
        Image::channels      = 3
        Image::pitch         = 30
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
      Framebuffer::depth = {
        Image::bytesPerPixel = 4
        Image::channels      = 1
        Image::pitch         = 40
        Image::format        = F32
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
      Framebuffer::stencil = {
        Image::bytesPerPixel = 1
        Image::channels      = 1
        Image::pitch         = 10
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data[] = {ff ff ff ff ff ff ff ff ff 00 ff ff ff ff ff ff ff ff 00 00 ff ff ff ff ff ff ff 00 00 00 ff ff ff ff ff ff 00 00 00 00 ff ff ff ff ff 00 00 00 00 00 ff ff ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00 00 00 ff ff 00 00 00 00 00 00 00 00 ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
        }
      }
  }
  GPUMemory::programs[100] = {
    0:
      Program::fragmentShader = shader
      Program::vertexShader   = shader
      Program::vs2fs[0]   = VEC4 
      Program::vs2fs[1]   = EMPTY
      Program::vs2fs[2]   = EMPTY
      Program::vs2fs[3]   = EMPTY
  }
  GPUMemory::buffers[100] = {
    0:
      Buffer::data = vertexBuffer0
      Buffer::size = 48
    1:
      Buffer::data = vertexBuffer1
      Buffer::size = 48
  }
  GPUMemory::vertexArrays[10000] = {
    0:
      VertexArray::indexBufferID = -1
      VertexArray::indexOffset   = 0
      VertexArray::indexType     = U32
      VertexArray::vertexAttrib[0].bufferID = 0
      VertexArray::vertexAttrib[0].offset   = 0
      VertexArray::vertexAttrib[0].stride   = 16
      VertexArray::vertexAttrib[0].type     = VEC4 
      VertexArray::vertexAttrib[1].bufferID = 1
      VertexArray::vertexAttrib[1].offset   = 0
      VertexArray::vertexAttrib[1].stride   = 16
      VertexArray::vertexAttrib[1].type     = VEC4 
  }
[0m
  Jak√© zmƒõny byly nad pamƒõt√≠ provedeny je≈°tƒõ p≈ôed spu≈°tƒõn√≠m:
[1;90m  float vertexBuffer0[12] = {
    -1,    -1,    0,    1,    -1,    1,    0,    1,    1,    -1,    0,    1,
  };
  float vertexBuffer1[12] = {
    1,    0,    0,    1,    0,    0,    1,    1,    0,    1,    0,    1,
  };
  GPUMemory::framebuffers[10] = {
    0:
      Framebuffer::width     = 10
      Framebuffer::height    = 10
      Framebuffer::yReversed = 0
      Framebuffer::color = {
        Image::bytesPerPixel = 3
        Image::channels      = 3
        Image::pitch         = 30
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
      Framebuffer::depth = {
        Image::bytesPerPixel = 4
        Image::channels      = 1
        Image::pitch         = 40
        Image::format        = F32
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
      Framebuffer::stencil = {
        Image::bytesPerPixel = 1
        Image::channels      = 1
        Image::pitch         = 10
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data[] = {00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
        }
      }
  }
  GPUMemory::programs[100] = {
    0:
      Program::fragmentShader = shader
      Program::vertexShader   = shader
      Program::vs2fs[0]   = VEC4 
      Program::vs2fs[1]   = EMPTY
      Program::vs2fs[2]   = EMPTY
      Program::vs2fs[3]   = EMPTY
  }
  GPUMemory::buffers[100] = {
    0:
      Buffer::data = vertexBuffer0
      Buffer::size = 48
    1:
      Buffer::data = vertexBuffer1
      Buffer::size = 48
  }
  GPUMemory::vertexArrays[10000] = {
    0:
      VertexArray::indexBufferID = -1
      VertexArray::indexOffset   = 0
      VertexArray::indexType     = U32
      VertexArray::vertexAttrib[0].bufferID = 0
      VertexArray::vertexAttrib[0].offset   = 0
      VertexArray::vertexAttrib[0].stride   = 16
      VertexArray::vertexAttrib[0].type     = VEC4 
      VertexArray::vertexAttrib[1].bufferID = 1
      VertexArray::vertexAttrib[1].offset   = 0
      VertexArray::vertexAttrib[1].stride   = 16
      VertexArray::vertexAttrib[1].type     = VEC4 
  }
[0m00 - All Stencil operations on sfail
  raster test: 0 - ok.
  raster test: 1 - ok.
  raster test: 2 - ok.
  raster test: 3 - ok.
  raster test: 4 - ok.
  raster test: 5 - ok.
  raster test: 6 - ok.
  raster test: 7 - ok.
  raster test: 8 - ok.
  raster test: 9 - ok.
  raster test: 10 - ok.
  raster test: 11 - ok.
  raster test: 12 - ok.
  raster test: 13 - ok.
  raster test: 14 - ok.
  raster test: 15 - ok.
  raster test: 16 - ok.
  raster test: 17 - ok.
  raster test: 18 - ok.
  raster test: 19 - ok.
  raster test: 20 - ok.
  raster test: 21 - ok.
  raster test: 22 - ok.
  raster test: 23 - ok.
  raster test: 24 - ok.
  raster test: 25 - ok.
  raster test: 26 - ok.
  raster test: 27 - ok.
  raster test: 28 - ok.
  raster test: 29 - ok.
  raster test: 30 - ok.
  raster test: 31 - ok.
  raster test: 32 - ok.
  raster test: 33 - ok.
  raster test: 34 - ok.
  raster test: 35 - ok.
  raster test: 36 - ok.
  raster test: 37 - ok.
  raster test: 38 - ok.
  raster test: 39 - ok.
  raster test: 40 - ok.
  raster test: 41 - ok.
  raster test: 42 - ok.
  raster test: 43 - ok.
  raster test: 44 - ok.
  raster test: 45 - ok.
  raster test: 46 - ok.
  raster test: 47 - ok.
  raster test: 48 - ok.
  raster test: 49 - ok.
  raster test: 50 - ok.
  raster test: 51 - ok.
  raster test: 52 - ok.
  raster test: 53 - ok.
  raster test: 54 - ok.
  raster test: 55 - ok.
  raster test: 56 - ok.
  raster test: 57 - ok.
  raster test: 58 - ok.
  raster test: 59 - ok.
  raster test: 60 - ok.
  raster test: 61 - ok.
  raster test: 62 - ok.
  raster test: 63 - ok.
  raster test: 64 - ok.
  raster test: 65 - ok.
  raster test: 66 - ok.
  raster test: 67 - ok.
  raster test: 68 - ok.
  raster test: 69 - ok.
  raster test: 70 - ok.
  raster test: 71 - ok.
  raster test: 72 - ok.
  raster test: 73 - ok.
  raster test: 74 - ok.
  raster test: 75 - ok.
  raster test: 76 - ok.
  raster test: 77 - ok.
  raster test: 78 - ok.
  raster test: 79 - ok.
  raster test: 80 - ok.
  raster test: 81 - ok.
  raster test: 82 - ok.
  raster test: 83 - ok.
  raster test: 84 - ok.
  raster test: 85 - ok.
  raster test: 86 - ok.
  raster test: 87 - ok.
  raster test: 88 - ok.
  raster test: 89 - ok.
  raster test: 90 - ok.
  raster test: 91 - ok.
  raster test: 92 - ok.
  raster test: 93 - ok.
  raster test: 94 - ok.
  raster test: 95 - ok.
  raster test: 96 - ok.
  raster test: 97 - ok.
  raster test: 98 - ok.
  raster test: 99 - ok.
  raster test: 100 - ok.
  raster test: 101 - ok.
  raster test: 102 - ok.
  raster test: 103 - ok.
  raster test: 104 - ok.
  raster test: 105 - ok.
  raster test: 106 - ok.
  raster test: 107 - ok.
  raster test: 108 - ok.
  raster test: 109 - ok.
  raster test: 110 - ok.
  raster test: 111 - ok.
  raster test: 112 - ok.
  raster test: 113 - ok.
  raster test: 114 - ok.
  raster test: 115 - ok.
  raster test: 116 - ok.
  raster test: 117 - ok.
  raster test: 118 - ok.
  raster test: 119 - ok.
  raster test: 120 - ok.
  raster test: 121 - ok.
  raster test: 122 - ok.
  raster test: 123 - ok.
  raster test: 124 - ok.
  raster test: 125 - ok.
  raster test: 126 - ok.
  raster test: 127 - ok.
  raster test: 128 - ok.
  raster test: 129 - ok.
  raster test: 130 - ok.
  raster test: 131 - ok.
  raster test: 132 - ok.
  raster test: 133 - ok.
  raster test: 134 - ok.
  raster test: 135 - ok.
  raster test: 136 - ok.
  raster test: 137 - ok.
  raster test: 138 - ok.
  raster test: 139 - ok.
  raster test: 140 - ok.
  raster test: 141 - ok.
  raster test: 142 - ok.
  raster test: 143 - ok.
00 - All Depth Tests
  raster test: 0 - ok.
  raster test: 1 - ok.

  Tento test kontroluje, zda spr√°vnƒõ funguje rastrov√° ƒç√°st grafick√© karty.

  Pr√°ce nad stencilov√Ωm bufferem je komplexn√≠.
  Z√°pis do stencilov√©ho bufferu je prov√°dƒõn rasterizac√≠.
  Je nƒõkolik druh≈Ø modifikac√≠ stencilov√©ho bufferu - viz struktura StencilOp.
  Operace se m≈Ø≈æe li≈°it pro p≈ôivr√°cen√© a odvr√°cen√© strany frontOps / backOps.
  A operace se m≈Ø≈æe li≈°it podle toho, zda sel≈æe stencilov√Ω test (sfail).
  Nebo zda sel≈æe depth test (dpfail).
  Nebo zda v≈°echny testy projdou (dppass).

  
  Nƒõco je ≈°patnƒõ...
  CHYBA! Rastrov√° ƒç√°st GPU nefunguje spr√°vnƒõ!
Raterizuje se troj√∫heln√≠k: A=(-1,-1,0,1)B=(-1,1,0,1)C=(1,-1,0,1)
P≈ôi rozli≈°en√≠: (10,10)

    Co≈æ odpov√≠d√° rasterizaci troj√∫heln√≠k≈Ø v NDC (po perspektivn√≠m dƒõlen√≠):
    A = vec3(-1,-1,0);
    B = vec3(-1,1,0);
    C = vec3(1,-1,0);

    Co≈æ odpov√≠d√° rasterizaci troj√∫heln√≠k≈Ø ve view-space:
    A = vec3(0,0,0);
    B = vec3(0,10,0);
    C = vec3(10,0,0);
    troj√∫heln√≠k je CW
Barevn√Ω    buffer: nen√≠
Stencilov√Ω buffer: nen√≠
Hloubkov√Ω  buffer byl inicializov√°n na: 0.9
CHYBA!

  ==========================
  === DETAILN√ç INFORMACE ===
  ==========================
  
  Command buffer v tomto testu vypad√° takto:
  
[1;90m  CommandBuffer::nofCommands = 8
  CommandBuffer::commands = {
    0:
      Command::type = CLEAR_COLOR                 
      ClearColorCommand::value = (0,0,0,0)
    1:
      Command::type = CLEAR_DEPTH                 
      ClearDepthCommand::value = 0.9
    2:
      Command::type = CLEAR_STENCIL               
      ClearStencilCommand::value = 0
    3:
      Command::type = BLOCK_WRITES_COMMAND        
      BlockWritesCommand::blockWrites = {
        BlockWrites::color   = false
        BlockWrites::depth   = false
        BlockWrites::stencil = false
      }
    4:
      Command::type = SET_BACKFACE_CULLING_COMMAND
      SetBackfaceCullingCommand::enabled = false
    5:
      Command::type = SET_FRONT_FACE_COMMAND      
      SetFrontFaceCommand::frontFaceIsCounterClockWise = true
    6:
      Command::type = SET_STENCIL_COMMAND         
      SetStencilCommand::settings = {
        StencilSettings::enabled         = false
        StencilSettings::refValue        = 0
        StencilSettings::func            = ALWAYS  
        Stencilsettings::backOps.sfail   = KEEP     
        Stencilsettings::backOps.dpfail  = KEEP     
        Stencilsettings::backOps.dppass  = KEEP     
        Stencilsettings::frontOps.sfail  = KEEP     
        Stencilsettings::frontOps.dpfail = KEEP     
        Stencilsettings::frontOps.dppass = KEEP     
      }
    7:
      Command::type = DRAW                        
      DrawCommand::nofVertices = 3
  }
[0m
  Jak se li≈°√≠ va≈°e zmƒõny nad pamƒõt√≠ od tƒõch, co se mƒõly prov√©st:
  
mem.framebuffers[0].depth.data = Image::bytesPerPixel = 4
Image::channels      = 1
Image::pitch         = 40
Image::format        = F32
Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
Image::data[] = {0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.9 0 0 0 0 0 0 0 0 0.9 0.9 0 0 0 0 0 0 0 0.9 0.9 0.9 0 0 0 0 0 0 0.9 0.9 0.9 0.9 0 0 0 0 0 0.9 0.9 0.9 0.9 0.9 0 0 0 0 0.9 0.9 0.9 0.9 0.9 0.9 0 0 0 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0 0 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 
}
;//va≈°e    
mem.framebuffers[0].depth.data = Image::bytesPerPixel = 4
Image::channels      = 1
Image::pitch         = 40
Image::format        = F32
Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
Image::data[] = {0 0 0 0 0 0 0 0 0 0.9 0 0 0 0 0 0 0 0 0.9 0.9 0 0 0 0 0 0 0 0.9 0.9 0.9 0 0 0 0 0 0 0.9 0.9 0.9 0.9 0 0 0 0 0 0.9 0.9 0.9 0.9 0.9 0 0 0 0 0.9 0.9 0.9 0.9 0.9 0.9 0 0 0 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0 0 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 
}
;//mƒõlo b√Ωt


  Jak√© zmƒõny jste nad pamƒõt√≠ provedli vy:
[1;90m  float vertexBuffer0[12] = {
    -1,    -1,    0,    1,    -1,    1,    0,    1,    1,    -1,    0,    1,
  };
  float vertexBuffer1[12] = {
    1,    0,    0,    1,    0,    0,    1,    1,    0,    1,    0,    1,
  };
  GPUMemory::gl_DrawID            = 1
  GPUMemory::framebuffers[10] = {
    0:
      Framebuffer::width     = 10
      Framebuffer::height    = 10
      Framebuffer::yReversed = 0
      Framebuffer::color = {
        Image::bytesPerPixel = 3
        Image::channels      = 3
        Image::pitch         = 30
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
      Framebuffer::depth = {
        Image::bytesPerPixel = 4
        Image::channels      = 1
        Image::pitch         = 40
        Image::format        = F32
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data[] = {0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.9 0 0 0 0 0 0 0 0 0.9 0.9 0 0 0 0 0 0 0 0.9 0.9 0.9 0 0 0 0 0 0 0.9 0.9 0.9 0.9 0 0 0 0 0 0.9 0.9 0.9 0.9 0.9 0 0 0 0 0.9 0.9 0.9 0.9 0.9 0.9 0 0 0 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0 0 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 
        }
      }
      Framebuffer::stencil = {
        Image::bytesPerPixel = 1
        Image::channels      = 1
        Image::pitch         = 10
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
  }
  GPUMemory::programs[100] = {
    0:
      Program::fragmentShader = shader
      Program::vertexShader   = shader
      Program::vs2fs[0]   = VEC4 
      Program::vs2fs[1]   = EMPTY
      Program::vs2fs[2]   = EMPTY
      Program::vs2fs[3]   = EMPTY
  }
  GPUMemory::buffers[100] = {
    0:
      Buffer::data = vertexBuffer0
      Buffer::size = 48
    1:
      Buffer::data = vertexBuffer1
      Buffer::size = 48
  }
  GPUMemory::vertexArrays[10000] = {
    0:
      VertexArray::indexBufferID = -1
      VertexArray::indexOffset   = 0
      VertexArray::indexType     = U32
      VertexArray::vertexAttrib[0].bufferID = 0
      VertexArray::vertexAttrib[0].offset   = 0
      VertexArray::vertexAttrib[0].stride   = 16
      VertexArray::vertexAttrib[0].type     = VEC4 
      VertexArray::vertexAttrib[1].bufferID = 1
      VertexArray::vertexAttrib[1].offset   = 0
      VertexArray::vertexAttrib[1].stride   = 16
      VertexArray::vertexAttrib[1].type     = VEC4 
  }
[0m
  Jak√© zmƒõny se nad pamƒõt√≠ mƒõly prov√©st:
[1;90m  float vertexBuffer0[12] = {
    -1,    -1,    0,    1,    -1,    1,    0,    1,    1,    -1,    0,    1,
  };
  float vertexBuffer1[12] = {
    1,    0,    0,    1,    0,    0,    1,    1,    0,    1,    0,    1,
  };
  GPUMemory::gl_DrawID            = 1
  GPUMemory::framebuffers[10] = {
    0:
      Framebuffer::width     = 10
      Framebuffer::height    = 10
      Framebuffer::yReversed = 0
      Framebuffer::color = {
        Image::bytesPerPixel = 3
        Image::channels      = 3
        Image::pitch         = 30
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
      Framebuffer::depth = {
        Image::bytesPerPixel = 4
        Image::channels      = 1
        Image::pitch         = 40
        Image::format        = F32
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data[] = {0 0 0 0 0 0 0 0 0 0.9 0 0 0 0 0 0 0 0 0.9 0.9 0 0 0 0 0 0 0 0.9 0.9 0.9 0 0 0 0 0 0 0.9 0.9 0.9 0.9 0 0 0 0 0 0.9 0.9 0.9 0.9 0.9 0 0 0 0 0.9 0.9 0.9 0.9 0.9 0.9 0 0 0 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0 0 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 
        }
      }
      Framebuffer::stencil = {
        Image::bytesPerPixel = 1
        Image::channels      = 1
        Image::pitch         = 10
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
  }
  GPUMemory::programs[100] = {
    0:
      Program::fragmentShader = shader
      Program::vertexShader   = shader
      Program::vs2fs[0]   = VEC4 
      Program::vs2fs[1]   = EMPTY
      Program::vs2fs[2]   = EMPTY
      Program::vs2fs[3]   = EMPTY
  }
  GPUMemory::buffers[100] = {
    0:
      Buffer::data = vertexBuffer0
      Buffer::size = 48
    1:
      Buffer::data = vertexBuffer1
      Buffer::size = 48
  }
  GPUMemory::vertexArrays[10000] = {
    0:
      VertexArray::indexBufferID = -1
      VertexArray::indexOffset   = 0
      VertexArray::indexType     = U32
      VertexArray::vertexAttrib[0].bufferID = 0
      VertexArray::vertexAttrib[0].offset   = 0
      VertexArray::vertexAttrib[0].stride   = 16
      VertexArray::vertexAttrib[0].type     = VEC4 
      VertexArray::vertexAttrib[1].bufferID = 1
      VertexArray::vertexAttrib[1].offset   = 0
      VertexArray::vertexAttrib[1].stride   = 16
      VertexArray::vertexAttrib[1].type     = VEC4 
  }
[0m
  Jak√© zmƒõny byly nad pamƒõt√≠ provedeny je≈°tƒõ p≈ôed spu≈°tƒõn√≠m:
[1;90m  float vertexBuffer0[12] = {
    -1,    -1,    0,    1,    -1,    1,    0,    1,    1,    -1,    0,    1,
  };
  float vertexBuffer1[12] = {
    1,    0,    0,    1,    0,    0,    1,    1,    0,    1,    0,    1,
  };
  GPUMemory::framebuffers[10] = {
    0:
      Framebuffer::width     = 10
      Framebuffer::height    = 10
      Framebuffer::yReversed = 0
      Framebuffer::color = {
        Image::bytesPerPixel = 3
        Image::channels      = 3
        Image::pitch         = 30
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
      Framebuffer::depth = {
        Image::bytesPerPixel = 4
        Image::channels      = 1
        Image::pitch         = 40
        Image::format        = F32
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data[] = {0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
        }
      }
      Framebuffer::stencil = {
        Image::bytesPerPixel = 1
        Image::channels      = 1
        Image::pitch         = 10
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
  }
  GPUMemory::programs[100] = {
    0:
      Program::fragmentShader = shader
      Program::vertexShader   = shader
      Program::vs2fs[0]   = VEC4 
      Program::vs2fs[1]   = EMPTY
      Program::vs2fs[2]   = EMPTY
      Program::vs2fs[3]   = EMPTY
  }
  GPUMemory::buffers[100] = {
    0:
      Buffer::data = vertexBuffer0
      Buffer::size = 48
    1:
      Buffer::data = vertexBuffer1
      Buffer::size = 48
  }
  GPUMemory::vertexArrays[10000] = {
    0:
      VertexArray::indexBufferID = -1
      VertexArray::indexOffset   = 0
      VertexArray::indexType     = U32
      VertexArray::vertexAttrib[0].bufferID = 0
      VertexArray::vertexAttrib[0].offset   = 0
      VertexArray::vertexAttrib[0].stride   = 16
      VertexArray::vertexAttrib[0].type     = VEC4 
      VertexArray::vertexAttrib[1].bufferID = 1
      VertexArray::vertexAttrib[1].offset   = 0
      VertexArray::vertexAttrib[1].stride   = 16
      VertexArray::vertexAttrib[1].type     = VEC4 
  }
[0m00 - All Stencil operations on dpfail
  raster test: 0 - ok.
  raster test: 1 - ok.
  raster test: 2 - ok.
  raster test: 3 - ok.
  raster test: 4 - ok.
  raster test: 5 - ok.
  raster test: 6 - ok.
  raster test: 7 - ok.
  raster test: 8 - ok.
  raster test: 9 - ok.
  raster test: 10 - ok.
  raster test: 11 - ok.
  raster test: 12 - ok.
  raster test: 13 - ok.
  raster test: 14 - ok.
  raster test: 15 - ok.
  raster test: 16 - ok.
  raster test: 17 - ok.
  raster test: 18 - ok.
  raster test: 19 - ok.
  raster test: 20 - ok.
  raster test: 21 - ok.
  raster test: 22 - ok.
  raster test: 23 - ok.
  raster test: 24 - ok.
  raster test: 25 - ok.
  raster test: 26 - ok.
  raster test: 27 - ok.
  raster test: 28 - ok.
  raster test: 29 - ok.
  raster test: 30 - ok.
  raster test: 31 - ok.
  raster test: 32 - ok.
  raster test: 33 - ok.
  raster test: 34 - ok.
  raster test: 35 - ok.
  raster test: 36 - ok.
  raster test: 37 - ok.
  raster test: 38 - ok.
  raster test: 39 - ok.
  raster test: 40 - ok.
  raster test: 41 - ok.
  raster test: 42 - ok.
  raster test: 43 - ok.
  raster test: 44 - ok.
  raster test: 45 - ok.
  raster test: 46 - ok.
  raster test: 47 - ok.
  raster test: 48 - ok.
  raster test: 49 - ok.
  raster test: 50 - ok.
  raster test: 51 - ok.
  raster test: 52 - ok.
  raster test: 53 - ok.
  raster test: 54 - ok.
  raster test: 55 - ok.
  raster test: 56 - ok.
  raster test: 57 - ok.
  raster test: 58 - ok.
  raster test: 59 - ok.
  raster test: 60 - ok.
  raster test: 61 - ok.
  raster test: 62 - ok.
  raster test: 63 - ok.
  raster test: 64 - ok.
  raster test: 65 - ok.
  raster test: 66 - ok.
  raster test: 67 - ok.
  raster test: 68 - ok.
  raster test: 69 - ok.
  raster test: 70 - ok.
  raster test: 71 - ok.
  raster test: 72 - ok.
  raster test: 73 - ok.
  raster test: 74 - ok.
  raster test: 75 - ok.
  raster test: 76 - ok.
  raster test: 77 - ok.
  raster test: 78 - ok.
  raster test: 79 - ok.
  raster test: 80 - ok.
  raster test: 81 - ok.
  raster test: 82 - ok.
  raster test: 83 - ok.
  raster test: 84 - ok.
  raster test: 85 - ok.
  raster test: 86 - ok.
  raster test: 87 - ok.
  raster test: 88 - ok.
  raster test: 89 - ok.
  raster test: 90 - ok.
  raster test: 91 - ok.
  raster test: 92 - ok.
  raster test: 93 - ok.
  raster test: 94 - ok.
  raster test: 95 - ok.
  raster test: 96 - ok.
  raster test: 97 - ok.
  raster test: 98 - ok.
  raster test: 99 - ok.
  raster test: 100 - ok.
  raster test: 101 - ok.
  raster test: 102 - ok.
  raster test: 103 - ok.
  raster test: 104 - ok.
  raster test: 105 - ok.
  raster test: 106 - ok.
  raster test: 107 - ok.
  raster test: 108 - ok.
  raster test: 109 - ok.
  raster test: 110 - ok.
  raster test: 111 - ok.
  raster test: 112 - ok.
  raster test: 113 - ok.
  raster test: 114 - ok.
  raster test: 115 - ok.
  raster test: 116 - ok.
  raster test: 117 - ok.
  raster test: 118 - ok.
  raster test: 119 - ok.
  raster test: 120 - ok.
  raster test: 121 - ok.
  raster test: 122 - ok.
  raster test: 123 - ok.
  raster test: 124 - ok.
  raster test: 125 - ok.
  raster test: 126 - ok.
  raster test: 127 - ok.
  raster test: 128 - ok.
  raster test: 129 - ok.
  raster test: 130 - ok.
  raster test: 131 - ok.
  raster test: 132 - ok.
  raster test: 133 - ok.
  raster test: 134 - ok.
  raster test: 135 - ok.
  raster test: 136 - ok.
  raster test: 137 - ok.
  raster test: 138 - ok.
  raster test: 139 - ok.
  raster test: 140 - ok.
  raster test: 141 - ok.
  raster test: 142 - ok.
  raster test: 143 - ok.
00 - discard test

  Tento test kontroluje, zda spr√°vnƒõ funguje rastrov√° ƒç√°st grafick√© karty.

  Pr√°ce nad stencilov√Ωm bufferem je komplexn√≠.
  Z√°pis do stencilov√©ho bufferu je prov√°dƒõn rasterizac√≠.
  Je nƒõkolik druh≈Ø modifikac√≠ stencilov√©ho bufferu - viz struktura StencilOp.
  Operace se m≈Ø≈æe li≈°it pro p≈ôivr√°cen√© a odvr√°cen√© strany frontOps / backOps.
  A operace se m≈Ø≈æe li≈°it podle toho, zda sel≈æe stencilov√Ω test (sfail).
  Nebo zda sel≈æe depth test (dpfail).
  Nebo zda v≈°echny testy projdou (dppass).

  
  Nƒõco je ≈°patnƒõ...
  CHYBA! Rastrov√° ƒç√°st GPU nefunguje spr√°vnƒõ!
Raterizuje se troj√∫heln√≠k: A=(-1,-1,0,1)B=(-1,1,0,1)C=(1,-1,0,1)
S barvami: CA=(1,0,0,1)CB=(0,0,1,1)CC=(0,1,0,1)
P≈ôi rozli≈°en√≠: (10,10)
Fragment shader ≈°achovnicovƒõ zahazuje fragmenty (nastavuje discard = true)

    Co≈æ odpov√≠d√° rasterizaci troj√∫heln√≠k≈Ø v NDC (po perspektivn√≠m dƒõlen√≠):
    A = vec3(-1,-1,0);
    B = vec3(-1,1,0);
    C = vec3(1,-1,0);

    Co≈æ odpov√≠d√° rasterizaci troj√∫heln√≠k≈Ø ve view-space:
    A = vec3(0,0,0);
    B = vec3(0,10,0);
    C = vec3(10,0,0);
    troj√∫heln√≠k je CW
Hloubkov√Ω  buffer: nen√≠
Stencilov√Ω buffer: nen√≠
Barevn√Ω    buffer byl inicializov√°n na: (0,0,0,0)
CHYBA!

  ==========================
  === DETAILN√ç INFORMACE ===
  ==========================
  
  Command buffer v tomto testu vypad√° takto:
  
[1;90m  CommandBuffer::nofCommands = 8
  CommandBuffer::commands = {
    0:
      Command::type = CLEAR_COLOR                 
      ClearColorCommand::value = (0,0,0,0)
    1:
      Command::type = CLEAR_DEPTH                 
      ClearDepthCommand::value = 1e+11
    2:
      Command::type = CLEAR_STENCIL               
      ClearStencilCommand::value = 0
    3:
      Command::type = BLOCK_WRITES_COMMAND        
      BlockWritesCommand::blockWrites = {
        BlockWrites::color   = false
        BlockWrites::depth   = false
        BlockWrites::stencil = false
      }
    4:
      Command::type = SET_BACKFACE_CULLING_COMMAND
      SetBackfaceCullingCommand::enabled = false
    5:
      Command::type = SET_FRONT_FACE_COMMAND      
      SetFrontFaceCommand::frontFaceIsCounterClockWise = true
    6:
      Command::type = SET_STENCIL_COMMAND         
      SetStencilCommand::settings = {
        StencilSettings::enabled         = false
        StencilSettings::refValue        = 0
        StencilSettings::func            = ALWAYS  
        Stencilsettings::backOps.sfail   = KEEP     
        Stencilsettings::backOps.dpfail  = KEEP     
        Stencilsettings::backOps.dppass  = KEEP     
        Stencilsettings::frontOps.sfail  = KEEP     
        Stencilsettings::frontOps.dpfail = KEEP     
        Stencilsettings::frontOps.dppass = KEEP     
      }
    7:
      Command::type = DRAW                        
      DrawCommand::nofVertices = 3
  }
[0m
  Jak se li≈°√≠ va≈°e zmƒõny nad pamƒõt√≠ od tƒõch, co se mƒõly prov√©st:
  
mem.framebuffers[0].color.data = Image::bytesPerPixel = 3
Image::channels      = 3
Image::pitch         = 30
Image::format        = U8 
Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
Image::data[] = {00 00 00 cc 26 0c 00 00 00 98 59 0c 00 00 00 65 8c 0c 00 00 00 33 bf 0c 00 00 00 00 f2 0c cc 0c 26 00 00 00 99 3f 26 00 00 00 66 72 26 00 00 00 33 a5 26 00 00 00 00 d8 26 00 00 00 00 00 00 99 26 3f 00 00 00 65 59 3f 00 00 00 32 8c 3f 00 00 00 00 bf 3f 00 00 00 00 00 00 99 0c 59 00 00 00 66 3f 59 00 00 00 33 72 59 00 00 00 00 a5 59 00 00 00 00 00 00 00 00 00 00 00 00 66 26 72 00 00 00 32 59 72 00 00 00 00 8c 72 00 00 00 00 00 00 00 00 00 00 00 00 65 0c 8c 00 00 00 32 3f 8c 00 00 00 00 72 8c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 33 26 a5 00 00 00 00 59 a5 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 32 0c bf 00 00 00 00 3f bf 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 26 d8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0c f2 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
}
;//va≈°e    
mem.framebuffers[0].color.data = Image::bytesPerPixel = 3
Image::channels      = 3
Image::pitch         = 30
Image::format        = U8 
Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
Image::data[] = {00 00 00 cc 26 0c 00 00 00 98 59 0c 00 00 00 65 8c 0c 00 00 00 32 bf 0c 00 00 00 00 00 00 cc 0c 26 00 00 00 99 3f 26 00 00 00 66 72 26 00 00 00 33 a5 26 00 00 00 00 00 00 00 00 00 00 00 00 99 26 3f 00 00 00 65 59 3f 00 00 00 32 8c 3f 00 00 00 00 00 00 00 00 00 00 00 00 99 0c 59 00 00 00 65 3f 59 00 00 00 33 72 59 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 66 26 72 00 00 00 32 59 72 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 65 0c 8c 00 00 00 32 3f 8c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 33 26 a5 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 32 0c bf 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
}
;//mƒõlo b√Ωt


  Jak√© zmƒõny jste nad pamƒõt√≠ provedli vy:
[1;90m  float vertexBuffer0[12] = {
    -1,    -1,    0,    1,    -1,    1,    0,    1,    1,    -1,    0,    1,
  };
  float vertexBuffer1[12] = {
    1,    0,    0,    1,    0,    0,    1,    1,    0,    1,    0,    1,
  };
  GPUMemory::gl_DrawID            = 1
  GPUMemory::framebuffers[10] = {
    0:
      Framebuffer::width     = 10
      Framebuffer::height    = 10
      Framebuffer::yReversed = 0
      Framebuffer::color = {
        Image::bytesPerPixel = 3
        Image::channels      = 3
        Image::pitch         = 30
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data[] = {00 00 00 cc 26 0c 00 00 00 98 59 0c 00 00 00 65 8c 0c 00 00 00 33 bf 0c 00 00 00 00 f2 0c cc 0c 26 00 00 00 99 3f 26 00 00 00 66 72 26 00 00 00 33 a5 26 00 00 00 00 d8 26 00 00 00 00 00 00 99 26 3f 00 00 00 65 59 3f 00 00 00 32 8c 3f 00 00 00 00 bf 3f 00 00 00 00 00 00 99 0c 59 00 00 00 66 3f 59 00 00 00 33 72 59 00 00 00 00 a5 59 00 00 00 00 00 00 00 00 00 00 00 00 66 26 72 00 00 00 32 59 72 00 00 00 00 8c 72 00 00 00 00 00 00 00 00 00 00 00 00 65 0c 8c 00 00 00 32 3f 8c 00 00 00 00 72 8c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 33 26 a5 00 00 00 00 59 a5 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 32 0c bf 00 00 00 00 3f bf 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 26 d8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0c f2 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
        }
      }
      Framebuffer::depth = {
        Image::bytesPerPixel = 4
        Image::channels      = 1
        Image::pitch         = 40
        Image::format        = F32
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
      Framebuffer::stencil = {
        Image::bytesPerPixel = 1
        Image::channels      = 1
        Image::pitch         = 10
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
  }
  GPUMemory::programs[100] = {
    0:
      Program::fragmentShader = shader
      Program::vertexShader   = shader
      Program::vs2fs[0]   = VEC4 
      Program::vs2fs[1]   = EMPTY
      Program::vs2fs[2]   = EMPTY
      Program::vs2fs[3]   = EMPTY
  }
  GPUMemory::buffers[100] = {
    0:
      Buffer::data = vertexBuffer0
      Buffer::size = 48
    1:
      Buffer::data = vertexBuffer1
      Buffer::size = 48
  }
  GPUMemory::vertexArrays[10000] = {
    0:
      VertexArray::indexBufferID = -1
      VertexArray::indexOffset   = 0
      VertexArray::indexType     = U32
      VertexArray::vertexAttrib[0].bufferID = 0
      VertexArray::vertexAttrib[0].offset   = 0
      VertexArray::vertexAttrib[0].stride   = 16
      VertexArray::vertexAttrib[0].type     = VEC4 
      VertexArray::vertexAttrib[1].bufferID = 1
      VertexArray::vertexAttrib[1].offset   = 0
      VertexArray::vertexAttrib[1].stride   = 16
      VertexArray::vertexAttrib[1].type     = VEC4 
  }
[0m
  Jak√© zmƒõny se nad pamƒõt√≠ mƒõly prov√©st:
[1;90m  float vertexBuffer0[12] = {
    -1,    -1,    0,    1,    -1,    1,    0,    1,    1,    -1,    0,    1,
  };
  float vertexBuffer1[12] = {
    1,    0,    0,    1,    0,    0,    1,    1,    0,    1,    0,    1,
  };
  GPUMemory::gl_DrawID            = 1
  GPUMemory::framebuffers[10] = {
    0:
      Framebuffer::width     = 10
      Framebuffer::height    = 10
      Framebuffer::yReversed = 0
      Framebuffer::color = {
        Image::bytesPerPixel = 3
        Image::channels      = 3
        Image::pitch         = 30
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data[] = {00 00 00 cc 26 0c 00 00 00 98 59 0c 00 00 00 65 8c 0c 00 00 00 32 bf 0c 00 00 00 00 00 00 cc 0c 26 00 00 00 99 3f 26 00 00 00 66 72 26 00 00 00 33 a5 26 00 00 00 00 00 00 00 00 00 00 00 00 99 26 3f 00 00 00 65 59 3f 00 00 00 32 8c 3f 00 00 00 00 00 00 00 00 00 00 00 00 99 0c 59 00 00 00 65 3f 59 00 00 00 33 72 59 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 66 26 72 00 00 00 32 59 72 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 65 0c 8c 00 00 00 32 3f 8c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 33 26 a5 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 32 0c bf 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
        }
      }
      Framebuffer::depth = {
        Image::bytesPerPixel = 4
        Image::channels      = 1
        Image::pitch         = 40
        Image::format        = F32
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
      Framebuffer::stencil = {
        Image::bytesPerPixel = 1
        Image::channels      = 1
        Image::pitch         = 10
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
  }
  GPUMemory::programs[100] = {
    0:
      Program::fragmentShader = shader
      Program::vertexShader   = shader
      Program::vs2fs[0]   = VEC4 
      Program::vs2fs[1]   = EMPTY
      Program::vs2fs[2]   = EMPTY
      Program::vs2fs[3]   = EMPTY
  }
  GPUMemory::buffers[100] = {
    0:
      Buffer::data = vertexBuffer0
      Buffer::size = 48
    1:
      Buffer::data = vertexBuffer1
      Buffer::size = 48
  }
  GPUMemory::vertexArrays[10000] = {
    0:
      VertexArray::indexBufferID = -1
      VertexArray::indexOffset   = 0
      VertexArray::indexType     = U32
      VertexArray::vertexAttrib[0].bufferID = 0
      VertexArray::vertexAttrib[0].offset   = 0
      VertexArray::vertexAttrib[0].stride   = 16
      VertexArray::vertexAttrib[0].type     = VEC4 
      VertexArray::vertexAttrib[1].bufferID = 1
      VertexArray::vertexAttrib[1].offset   = 0
      VertexArray::vertexAttrib[1].stride   = 16
      VertexArray::vertexAttrib[1].type     = VEC4 
  }
[0m
  Jak√© zmƒõny byly nad pamƒõt√≠ provedeny je≈°tƒõ p≈ôed spu≈°tƒõn√≠m:
[1;90m  float vertexBuffer0[12] = {
    -1,    -1,    0,    1,    -1,    1,    0,    1,    1,    -1,    0,    1,
  };
  float vertexBuffer1[12] = {
    1,    0,    0,    1,    0,    0,    1,    1,    0,    1,    0,    1,
  };
  GPUMemory::framebuffers[10] = {
    0:
      Framebuffer::width     = 10
      Framebuffer::height    = 10
      Framebuffer::yReversed = 0
      Framebuffer::color = {
        Image::bytesPerPixel = 3
        Image::channels      = 3
        Image::pitch         = 30
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data[] = {00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
        }
      }
      Framebuffer::depth = {
        Image::bytesPerPixel = 4
        Image::channels      = 1
        Image::pitch         = 40
        Image::format        = F32
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
      Framebuffer::stencil = {
        Image::bytesPerPixel = 1
        Image::channels      = 1
        Image::pitch         = 10
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
  }
  GPUMemory::programs[100] = {
    0:
      Program::fragmentShader = shader
      Program::vertexShader   = shader
      Program::vs2fs[0]   = VEC4 
      Program::vs2fs[1]   = EMPTY
      Program::vs2fs[2]   = EMPTY
      Program::vs2fs[3]   = EMPTY
  }
  GPUMemory::buffers[100] = {
    0:
      Buffer::data = vertexBuffer0
      Buffer::size = 48
    1:
      Buffer::data = vertexBuffer1
      Buffer::size = 48
  }
  GPUMemory::vertexArrays[10000] = {
    0:
      VertexArray::indexBufferID = -1
      VertexArray::indexOffset   = 0
      VertexArray::indexType     = U32
      VertexArray::vertexAttrib[0].bufferID = 0
      VertexArray::vertexAttrib[0].offset   = 0
      VertexArray::vertexAttrib[0].stride   = 16
      VertexArray::vertexAttrib[0].type     = VEC4 
      VertexArray::vertexAttrib[1].bufferID = 1
      VertexArray::vertexAttrib[1].offset   = 0
      VertexArray::vertexAttrib[1].stride   = 16
      VertexArray::vertexAttrib[1].type     = VEC4 
  }
[0m00 - All Stencil operations on dppass
  raster test: 0 - ok.
  raster test: 1 - ok.
  raster test: 2 - ok.
  raster test: 3 - ok.
  raster test: 4 - ok.
  raster test: 5 - ok.
  raster test: 6 - ok.
  raster test: 7 - ok.
  raster test: 8 - ok.
  raster test: 9 - ok.
  raster test: 10 - ok.
  raster test: 11 - ok.
  raster test: 12 - ok.
  raster test: 13 - ok.
  raster test: 14 - ok.
  raster test: 15 - ok.
  raster test: 16 - ok.
  raster test: 17 - ok.
  raster test: 18 - ok.
  raster test: 19 - ok.
  raster test: 20 - ok.
  raster test: 21 - ok.
  raster test: 22 - ok.
  raster test: 23 - ok.
  raster test: 24 - ok.
  raster test: 25 - ok.
  raster test: 26 - ok.
  raster test: 27 - ok.
  raster test: 28 - ok.
  raster test: 29 - ok.
  raster test: 30 - ok.
  raster test: 31 - ok.
  raster test: 32 - ok.
  raster test: 33 - ok.
  raster test: 34 - ok.
  raster test: 35 - ok.
  raster test: 36 - ok.
  raster test: 37 - ok.
  raster test: 38 - ok.
  raster test: 39 - ok.
  raster test: 40 - ok.
  raster test: 41 - ok.
  raster test: 42 - ok.
  raster test: 43 - ok.
  raster test: 44 - ok.
  raster test: 45 - ok.
  raster test: 46 - ok.
  raster test: 47 - ok.
  raster test: 48 - ok.
  raster test: 49 - ok.
  raster test: 50 - ok.
  raster test: 51 - ok.
  raster test: 52 - ok.
  raster test: 53 - ok.
  raster test: 54 - ok.
  raster test: 55 - ok.
  raster test: 56 - ok.
  raster test: 57 - ok.
  raster test: 58 - ok.
  raster test: 59 - ok.
  raster test: 60 - ok.
  raster test: 61 - ok.
  raster test: 62 - ok.
  raster test: 63 - ok.
  raster test: 64 - ok.
  raster test: 65 - ok.
  raster test: 66 - ok.
  raster test: 67 - ok.
  raster test: 68 - ok.
  raster test: 69 - ok.
  raster test: 70 - ok.
  raster test: 71 - ok.
  raster test: 72 - ok.
  raster test: 73 - ok.
  raster test: 74 - ok.
  raster test: 75 - ok.
  raster test: 76 - ok.
  raster test: 77 - ok.
  raster test: 78 - ok.
  raster test: 79 - ok.
  raster test: 80 - ok.
  raster test: 81 - ok.
  raster test: 82 - ok.
  raster test: 83 - ok.
  raster test: 84 - ok.
  raster test: 85 - ok.
  raster test: 86 - ok.
  raster test: 87 - ok.
  raster test: 88 - ok.
  raster test: 89 - ok.
  raster test: 90 - ok.
  raster test: 91 - ok.
  raster test: 92 - ok.
  raster test: 93 - ok.
  raster test: 94 - ok.
  raster test: 95 - ok.
  raster test: 96 - ok.
  raster test: 97 - ok.
  raster test: 98 - ok.
  raster test: 99 - ok.
  raster test: 100 - ok.
  raster test: 101 - ok.
  raster test: 102 - ok.
  raster test: 103 - ok.
  raster test: 104 - ok.
  raster test: 105 - ok.
  raster test: 106 - ok.
  raster test: 107 - ok.
  raster test: 108 - ok.
  raster test: 109 - ok.
  raster test: 110 - ok.
  raster test: 111 - ok.
  raster test: 112 - ok.
  raster test: 113 - ok.
  raster test: 114 - ok.
  raster test: 115 - ok.
  raster test: 116 - ok.
  raster test: 117 - ok.
  raster test: 118 - ok.
  raster test: 119 - ok.
  raster test: 120 - ok.
  raster test: 121 - ok.
  raster test: 122 - ok.
  raster test: 123 - ok.
  raster test: 124 - ok.
  raster test: 125 - ok.
  raster test: 126 - ok.
  raster test: 127 - ok.
  raster test: 128 - ok.
  raster test: 129 - ok.
  raster test: 130 - ok.
  raster test: 131 - ok.
  raster test: 132 - ok.
  raster test: 133 - ok.
  raster test: 134 - ok.
  raster test: 135 - ok.
  raster test: 136 - ok.
  raster test: 137 - ok.
  raster test: 138 - ok.
  raster test: 139 - ok.
  raster test: 140 - ok.
  raster test: 141 - ok.
  raster test: 142 - ok.
  raster test: 143 - ok.
00 - Depth writes
  raster test: 0 - ok.
  raster test: 1 - ok.

  Tento test kontroluje, zda spr√°vnƒõ funguje rastrov√° ƒç√°st grafick√© karty.

  Pr√°ce nad stencilov√Ωm bufferem je komplexn√≠.
  Z√°pis do stencilov√©ho bufferu je prov√°dƒõn rasterizac√≠.
  Je nƒõkolik druh≈Ø modifikac√≠ stencilov√©ho bufferu - viz struktura StencilOp.
  Operace se m≈Ø≈æe li≈°it pro p≈ôivr√°cen√© a odvr√°cen√© strany frontOps / backOps.
  A operace se m≈Ø≈æe li≈°it podle toho, zda sel≈æe stencilov√Ω test (sfail).
  Nebo zda sel≈æe depth test (dpfail).
  Nebo zda v≈°echny testy projdou (dppass).

  
  Nƒõco je ≈°patnƒõ...
  CHYBA! Rastrov√° ƒç√°st GPU nefunguje spr√°vnƒõ!
Raterizuje se troj√∫heln√≠k: A=(-1,-1,0,1)B=(-1,1,0,1)C=(1,-1,0,1)
P≈ôi rozli≈°en√≠: (10,10)

    Co≈æ odpov√≠d√° rasterizaci troj√∫heln√≠k≈Ø v NDC (po perspektivn√≠m dƒõlen√≠):
    A = vec3(-1,-1,0);
    B = vec3(-1,1,0);
    C = vec3(1,-1,0);

    Co≈æ odpov√≠d√° rasterizaci troj√∫heln√≠k≈Ø ve view-space:
    A = vec3(0,0,0);
    B = vec3(0,10,0);
    C = vec3(10,0,0);
    troj√∫heln√≠k je CW
Barevn√Ω    buffer: nen√≠
Stencilov√Ω buffer: nen√≠
Hloubkov√Ω  buffer byl inicializov√°n na: 1e+11
CHYBA!

  ==========================
  === DETAILN√ç INFORMACE ===
  ==========================
  
  Command buffer v tomto testu vypad√° takto:
  
[1;90m  CommandBuffer::nofCommands = 8
  CommandBuffer::commands = {
    0:
      Command::type = CLEAR_COLOR                 
      ClearColorCommand::value = (0,0,0,0)
    1:
      Command::type = CLEAR_DEPTH                 
      ClearDepthCommand::value = 1e+11
    2:
      Command::type = CLEAR_STENCIL               
      ClearStencilCommand::value = 0
    3:
      Command::type = BLOCK_WRITES_COMMAND        
      BlockWritesCommand::blockWrites = {
        BlockWrites::color   = false
        BlockWrites::depth   = false
        BlockWrites::stencil = false
      }
    4:
      Command::type = SET_BACKFACE_CULLING_COMMAND
      SetBackfaceCullingCommand::enabled = false
    5:
      Command::type = SET_FRONT_FACE_COMMAND      
      SetFrontFaceCommand::frontFaceIsCounterClockWise = true
    6:
      Command::type = SET_STENCIL_COMMAND         
      SetStencilCommand::settings = {
        StencilSettings::enabled         = false
        StencilSettings::refValue        = 0
        StencilSettings::func            = ALWAYS  
        Stencilsettings::backOps.sfail   = KEEP     
        Stencilsettings::backOps.dpfail  = KEEP     
        Stencilsettings::backOps.dppass  = KEEP     
        Stencilsettings::frontOps.sfail  = KEEP     
        Stencilsettings::frontOps.dpfail = KEEP     
        Stencilsettings::frontOps.dppass = KEEP     
      }
    7:
      Command::type = DRAW                        
      DrawCommand::nofVertices = 3
  }
[0m
  Jak se li≈°√≠ va≈°e zmƒõny nad pamƒõt√≠ od tƒõch, co se mƒõly prov√©st:
  
mem.framebuffers[0].depth.data = Image::bytesPerPixel = 4
Image::channels      = 1
Image::pitch         = 40
Image::format        = F32
Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
Image::data[] = {0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1e+11 0 0 0 0 0 0 0 0 1e+11 1e+11 0 0 0 0 0 0 0 1e+11 1e+11 1e+11 0 0 0 0 0 0 1e+11 1e+11 1e+11 1e+11 0 0 0 0 0 1e+11 1e+11 1e+11 1e+11 1e+11 0 0 0 0 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 0 0 0 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 0 0 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 0 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 
}
;//va≈°e    
mem.framebuffers[0].depth.data = Image::bytesPerPixel = 4
Image::channels      = 1
Image::pitch         = 40
Image::format        = F32
Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
Image::data[] = {0 0 0 0 0 0 0 0 0 1e+11 0 0 0 0 0 0 0 0 1e+11 1e+11 0 0 0 0 0 0 0 1e+11 1e+11 1e+11 0 0 0 0 0 0 1e+11 1e+11 1e+11 1e+11 0 0 0 0 0 1e+11 1e+11 1e+11 1e+11 1e+11 0 0 0 0 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 0 0 0 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 0 0 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 0 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 
}
;//mƒõlo b√Ωt


  Jak√© zmƒõny jste nad pamƒõt√≠ provedli vy:
[1;90m  float vertexBuffer0[12] = {
    -1,    -1,    0,    1,    -1,    1,    0,    1,    1,    -1,    0,    1,
  };
  float vertexBuffer1[12] = {
    1,    0,    0,    1,    0,    0,    1,    1,    0,    1,    0,    1,
  };
  GPUMemory::gl_DrawID            = 1
  GPUMemory::framebuffers[10] = {
    0:
      Framebuffer::width     = 10
      Framebuffer::height    = 10
      Framebuffer::yReversed = 0
      Framebuffer::color = {
        Image::bytesPerPixel = 3
        Image::channels      = 3
        Image::pitch         = 30
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
      Framebuffer::depth = {
        Image::bytesPerPixel = 4
        Image::channels      = 1
        Image::pitch         = 40
        Image::format        = F32
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data[] = {0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1e+11 0 0 0 0 0 0 0 0 1e+11 1e+11 0 0 0 0 0 0 0 1e+11 1e+11 1e+11 0 0 0 0 0 0 1e+11 1e+11 1e+11 1e+11 0 0 0 0 0 1e+11 1e+11 1e+11 1e+11 1e+11 0 0 0 0 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 0 0 0 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 0 0 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 0 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 
        }
      }
      Framebuffer::stencil = {
        Image::bytesPerPixel = 1
        Image::channels      = 1
        Image::pitch         = 10
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
  }
  GPUMemory::programs[100] = {
    0:
      Program::fragmentShader = shader
      Program::vertexShader   = shader
      Program::vs2fs[0]   = VEC4 
      Program::vs2fs[1]   = EMPTY
      Program::vs2fs[2]   = EMPTY
      Program::vs2fs[3]   = EMPTY
  }
  GPUMemory::buffers[100] = {
    0:
      Buffer::data = vertexBuffer0
      Buffer::size = 48
    1:
      Buffer::data = vertexBuffer1
      Buffer::size = 48
  }
  GPUMemory::vertexArrays[10000] = {
    0:
      VertexArray::indexBufferID = -1
      VertexArray::indexOffset   = 0
      VertexArray::indexType     = U32
      VertexArray::vertexAttrib[0].bufferID = 0
      VertexArray::vertexAttrib[0].offset   = 0
      VertexArray::vertexAttrib[0].stride   = 16
      VertexArray::vertexAttrib[0].type     = VEC4 
      VertexArray::vertexAttrib[1].bufferID = 1
      VertexArray::vertexAttrib[1].offset   = 0
      VertexArray::vertexAttrib[1].stride   = 16
      VertexArray::vertexAttrib[1].type     = VEC4 
  }
[0m
  Jak√© zmƒõny se nad pamƒõt√≠ mƒõly prov√©st:
[1;90m  float vertexBuffer0[12] = {
    -1,    -1,    0,    1,    -1,    1,    0,    1,    1,    -1,    0,    1,
  };
  float vertexBuffer1[12] = {
    1,    0,    0,    1,    0,    0,    1,    1,    0,    1,    0,    1,
  };
  GPUMemory::gl_DrawID            = 1
  GPUMemory::framebuffers[10] = {
    0:
      Framebuffer::width     = 10
      Framebuffer::height    = 10
      Framebuffer::yReversed = 0
      Framebuffer::color = {
        Image::bytesPerPixel = 3
        Image::channels      = 3
        Image::pitch         = 30
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
      Framebuffer::depth = {
        Image::bytesPerPixel = 4
        Image::channels      = 1
        Image::pitch         = 40
        Image::format        = F32
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data[] = {0 0 0 0 0 0 0 0 0 1e+11 0 0 0 0 0 0 0 0 1e+11 1e+11 0 0 0 0 0 0 0 1e+11 1e+11 1e+11 0 0 0 0 0 0 1e+11 1e+11 1e+11 1e+11 0 0 0 0 0 1e+11 1e+11 1e+11 1e+11 1e+11 0 0 0 0 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 0 0 0 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 0 0 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 0 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 1e+11 
        }
      }
      Framebuffer::stencil = {
        Image::bytesPerPixel = 1
        Image::channels      = 1
        Image::pitch         = 10
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
  }
  GPUMemory::programs[100] = {
    0:
      Program::fragmentShader = shader
      Program::vertexShader   = shader
      Program::vs2fs[0]   = VEC4 
      Program::vs2fs[1]   = EMPTY
      Program::vs2fs[2]   = EMPTY
      Program::vs2fs[3]   = EMPTY
  }
  GPUMemory::buffers[100] = {
    0:
      Buffer::data = vertexBuffer0
      Buffer::size = 48
    1:
      Buffer::data = vertexBuffer1
      Buffer::size = 48
  }
  GPUMemory::vertexArrays[10000] = {
    0:
      VertexArray::indexBufferID = -1
      VertexArray::indexOffset   = 0
      VertexArray::indexType     = U32
      VertexArray::vertexAttrib[0].bufferID = 0
      VertexArray::vertexAttrib[0].offset   = 0
      VertexArray::vertexAttrib[0].stride   = 16
      VertexArray::vertexAttrib[0].type     = VEC4 
      VertexArray::vertexAttrib[1].bufferID = 1
      VertexArray::vertexAttrib[1].offset   = 0
      VertexArray::vertexAttrib[1].stride   = 16
      VertexArray::vertexAttrib[1].type     = VEC4 
  }
[0m
  Jak√© zmƒõny byly nad pamƒõt√≠ provedeny je≈°tƒõ p≈ôed spu≈°tƒõn√≠m:
[1;90m  float vertexBuffer0[12] = {
    -1,    -1,    0,    1,    -1,    1,    0,    1,    1,    -1,    0,    1,
  };
  float vertexBuffer1[12] = {
    1,    0,    0,    1,    0,    0,    1,    1,    0,    1,    0,    1,
  };
  GPUMemory::framebuffers[10] = {
    0:
      Framebuffer::width     = 10
      Framebuffer::height    = 10
      Framebuffer::yReversed = 0
      Framebuffer::color = {
        Image::bytesPerPixel = 3
        Image::channels      = 3
        Image::pitch         = 30
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
      Framebuffer::depth = {
        Image::bytesPerPixel = 4
        Image::channels      = 1
        Image::pitch         = 40
        Image::format        = F32
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data[] = {0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
        }
      }
      Framebuffer::stencil = {
        Image::bytesPerPixel = 1
        Image::channels      = 1
        Image::pitch         = 10
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
  }
  GPUMemory::programs[100] = {
    0:
      Program::fragmentShader = shader
      Program::vertexShader   = shader
      Program::vs2fs[0]   = VEC4 
      Program::vs2fs[1]   = EMPTY
      Program::vs2fs[2]   = EMPTY
      Program::vs2fs[3]   = EMPTY
  }
  GPUMemory::buffers[100] = {
    0:
      Buffer::data = vertexBuffer0
      Buffer::size = 48
    1:
      Buffer::data = vertexBuffer1
      Buffer::size = 48
  }
  GPUMemory::vertexArrays[10000] = {
    0:
      VertexArray::indexBufferID = -1
      VertexArray::indexOffset   = 0
      VertexArray::indexType     = U32
      VertexArray::vertexAttrib[0].bufferID = 0
      VertexArray::vertexAttrib[0].offset   = 0
      VertexArray::vertexAttrib[0].stride   = 16
      VertexArray::vertexAttrib[0].type     = VEC4 
      VertexArray::vertexAttrib[1].bufferID = 1
      VertexArray::vertexAttrib[1].offset   = 0
      VertexArray::vertexAttrib[1].stride   = 16
      VertexArray::vertexAttrib[1].type     = VEC4 
  }
[0m00 - Color writes
  raster test: 0 - ok.
  raster test: 1 - ok.

  Tento test kontroluje, zda spr√°vnƒõ funguje rastrov√° ƒç√°st grafick√© karty.

  Pr√°ce nad stencilov√Ωm bufferem je komplexn√≠.
  Z√°pis do stencilov√©ho bufferu je prov√°dƒõn rasterizac√≠.
  Je nƒõkolik druh≈Ø modifikac√≠ stencilov√©ho bufferu - viz struktura StencilOp.
  Operace se m≈Ø≈æe li≈°it pro p≈ôivr√°cen√© a odvr√°cen√© strany frontOps / backOps.
  A operace se m≈Ø≈æe li≈°it podle toho, zda sel≈æe stencilov√Ω test (sfail).
  Nebo zda sel≈æe depth test (dpfail).
  Nebo zda v≈°echny testy projdou (dppass).

  
  Nƒõco je ≈°patnƒõ...
  CHYBA! Rastrov√° ƒç√°st GPU nefunguje spr√°vnƒõ!
Raterizuje se troj√∫heln√≠k: A=(-1,-1,0,1)B=(-1,1,0,1)C=(1,-1,0,1)
S barvami: CA=(1,0,0,1)CB=(0,0,1,1)CC=(0,1,0,1)
P≈ôi rozli≈°en√≠: (10,10)

    Co≈æ odpov√≠d√° rasterizaci troj√∫heln√≠k≈Ø v NDC (po perspektivn√≠m dƒõlen√≠):
    A = vec3(-1,-1,0);
    B = vec3(-1,1,0);
    C = vec3(1,-1,0);

    Co≈æ odpov√≠d√° rasterizaci troj√∫heln√≠k≈Ø ve view-space:
    A = vec3(0,0,0);
    B = vec3(0,10,0);
    C = vec3(10,0,0);
    troj√∫heln√≠k je CW
Hloubkov√Ω  buffer: nen√≠
Stencilov√Ω buffer: nen√≠
Barevn√Ω    buffer byl inicializov√°n na: (0,0,0,0)
CHYBA!

  ==========================
  === DETAILN√ç INFORMACE ===
  ==========================
  
  Command buffer v tomto testu vypad√° takto:
  
[1;90m  CommandBuffer::nofCommands = 8
  CommandBuffer::commands = {
    0:
      Command::type = CLEAR_COLOR                 
      ClearColorCommand::value = (0,0,0,0)
    1:
      Command::type = CLEAR_DEPTH                 
      ClearDepthCommand::value = 1e+11
    2:
      Command::type = CLEAR_STENCIL               
      ClearStencilCommand::value = 0
    3:
      Command::type = BLOCK_WRITES_COMMAND        
      BlockWritesCommand::blockWrites = {
        BlockWrites::color   = false
        BlockWrites::depth   = false
        BlockWrites::stencil = false
      }
    4:
      Command::type = SET_BACKFACE_CULLING_COMMAND
      SetBackfaceCullingCommand::enabled = false
    5:
      Command::type = SET_FRONT_FACE_COMMAND      
      SetFrontFaceCommand::frontFaceIsCounterClockWise = true
    6:
      Command::type = SET_STENCIL_COMMAND         
      SetStencilCommand::settings = {
        StencilSettings::enabled         = false
        StencilSettings::refValue        = 0
        StencilSettings::func            = ALWAYS  
        Stencilsettings::backOps.sfail   = KEEP     
        Stencilsettings::backOps.dpfail  = KEEP     
        Stencilsettings::backOps.dppass  = KEEP     
        Stencilsettings::frontOps.sfail  = KEEP     
        Stencilsettings::frontOps.dpfail = KEEP     
        Stencilsettings::frontOps.dppass = KEEP     
      }
    7:
      Command::type = DRAW                        
      DrawCommand::nofVertices = 3
  }
[0m
  Jak se li≈°√≠ va≈°e zmƒõny nad pamƒõt√≠ od tƒõch, co se mƒõly prov√©st:
  
mem.framebuffers[0].color.data = Image::bytesPerPixel = 3
Image::channels      = 3
Image::pitch         = 30
Image::format        = U8 
Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
Image::data[] = {e5 0c 0c cc 26 0c b2 3f 0c 98 59 0c 7f 72 0c 65 8c 0c 4c a5 0c 33 bf 0c 19 d8 0c 00 f2 0c cc 0c 26 b2 26 26 99 3f 26 7f 59 26 66 72 26 4c 8c 26 33 a5 26 19 bf 26 00 d8 26 00 00 00 b2 0c 3f 99 26 3f 7f 3f 3f 65 59 3f 4c 72 3f 32 8c 3f 19 a5 3f 00 bf 3f 00 00 00 00 00 00 99 0c 59 7f 26 59 66 3f 59 4c 59 59 33 72 59 19 8c 59 00 a5 59 00 00 00 00 00 00 00 00 00 7f 0c 72 66 26 72 4c 3f 72 32 59 72 19 72 72 00 8c 72 00 00 00 00 00 00 00 00 00 00 00 00 65 0c 8c 4c 26 8c 32 3f 8c 19 59 8c 00 72 8c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 4c 0c a5 33 26 a5 19 3f a5 00 59 a5 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 32 0c bf 19 26 bf 00 3f bf 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 19 0c d8 00 26 d8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0c f2 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
}
;//va≈°e    
mem.framebuffers[0].color.data = Image::bytesPerPixel = 3
Image::channels      = 3
Image::pitch         = 30
Image::format        = U8 
Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
Image::data[] = {e5 0c 0c cc 26 0c b2 3f 0c 98 59 0c 7f 72 0c 65 8c 0c 4c a5 0c 32 bf 0c 19 d8 0c 00 00 00 cc 0c 26 b2 26 26 99 3f 26 7f 59 26 66 72 26 4c 8c 26 33 a5 26 19 bf 26 00 00 00 00 00 00 b2 0c 3f 99 26 3f 7f 3f 3f 65 59 3f 4c 72 3f 32 8c 3f 19 a5 3f 00 00 00 00 00 00 00 00 00 99 0c 59 7f 26 59 65 3f 59 4c 59 59 33 72 59 19 8c 59 00 00 00 00 00 00 00 00 00 00 00 00 7f 0c 72 66 26 72 4c 3f 72 32 59 72 19 72 72 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 65 0c 8c 4c 26 8c 32 3f 8c 19 59 8c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 4c 0c a5 33 26 a5 19 3f a5 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 32 0c bf 19 26 bf 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 19 0c d8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
}
;//mƒõlo b√Ωt


  Jak√© zmƒõny jste nad pamƒõt√≠ provedli vy:
[1;90m  float vertexBuffer0[12] = {
    -1,    -1,    0,    1,    -1,    1,    0,    1,    1,    -1,    0,    1,
  };
  float vertexBuffer1[12] = {
    1,    0,    0,    1,    0,    0,    1,    1,    0,    1,    0,    1,
  };
  GPUMemory::gl_DrawID            = 1
  GPUMemory::framebuffers[10] = {
    0:
      Framebuffer::width     = 10
      Framebuffer::height    = 10
      Framebuffer::yReversed = 0
      Framebuffer::color = {
        Image::bytesPerPixel = 3
        Image::channels      = 3
        Image::pitch         = 30
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data[] = {e5 0c 0c cc 26 0c b2 3f 0c 98 59 0c 7f 72 0c 65 8c 0c 4c a5 0c 33 bf 0c 19 d8 0c 00 f2 0c cc 0c 26 b2 26 26 99 3f 26 7f 59 26 66 72 26 4c 8c 26 33 a5 26 19 bf 26 00 d8 26 00 00 00 b2 0c 3f 99 26 3f 7f 3f 3f 65 59 3f 4c 72 3f 32 8c 3f 19 a5 3f 00 bf 3f 00 00 00 00 00 00 99 0c 59 7f 26 59 66 3f 59 4c 59 59 33 72 59 19 8c 59 00 a5 59 00 00 00 00 00 00 00 00 00 7f 0c 72 66 26 72 4c 3f 72 32 59 72 19 72 72 00 8c 72 00 00 00 00 00 00 00 00 00 00 00 00 65 0c 8c 4c 26 8c 32 3f 8c 19 59 8c 00 72 8c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 4c 0c a5 33 26 a5 19 3f a5 00 59 a5 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 32 0c bf 19 26 bf 00 3f bf 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 19 0c d8 00 26 d8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0c f2 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
        }
      }
      Framebuffer::depth = {
        Image::bytesPerPixel = 4
        Image::channels      = 1
        Image::pitch         = 40
        Image::format        = F32
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
      Framebuffer::stencil = {
        Image::bytesPerPixel = 1
        Image::channels      = 1
        Image::pitch         = 10
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
  }
  GPUMemory::programs[100] = {
    0:
      Program::fragmentShader = shader
      Program::vertexShader   = shader
      Program::vs2fs[0]   = VEC4 
      Program::vs2fs[1]   = EMPTY
      Program::vs2fs[2]   = EMPTY
      Program::vs2fs[3]   = EMPTY
  }
  GPUMemory::buffers[100] = {
    0:
      Buffer::data = vertexBuffer0
      Buffer::size = 48
    1:
      Buffer::data = vertexBuffer1
      Buffer::size = 48
  }
  GPUMemory::vertexArrays[10000] = {
    0:
      VertexArray::indexBufferID = -1
      VertexArray::indexOffset   = 0
      VertexArray::indexType     = U32
      VertexArray::vertexAttrib[0].bufferID = 0
      VertexArray::vertexAttrib[0].offset   = 0
      VertexArray::vertexAttrib[0].stride   = 16
      VertexArray::vertexAttrib[0].type     = VEC4 
      VertexArray::vertexAttrib[1].bufferID = 1
      VertexArray::vertexAttrib[1].offset   = 0
      VertexArray::vertexAttrib[1].stride   = 16
      VertexArray::vertexAttrib[1].type     = VEC4 
  }
[0m
  Jak√© zmƒõny se nad pamƒõt√≠ mƒõly prov√©st:
[1;90m  float vertexBuffer0[12] = {
    -1,    -1,    0,    1,    -1,    1,    0,    1,    1,    -1,    0,    1,
  };
  float vertexBuffer1[12] = {
    1,    0,    0,    1,    0,    0,    1,    1,    0,    1,    0,    1,
  };
  GPUMemory::gl_DrawID            = 1
  GPUMemory::framebuffers[10] = {
    0:
      Framebuffer::width     = 10
      Framebuffer::height    = 10
      Framebuffer::yReversed = 0
      Framebuffer::color = {
        Image::bytesPerPixel = 3
        Image::channels      = 3
        Image::pitch         = 30
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data[] = {e5 0c 0c cc 26 0c b2 3f 0c 98 59 0c 7f 72 0c 65 8c 0c 4c a5 0c 32 bf 0c 19 d8 0c 00 00 00 cc 0c 26 b2 26 26 99 3f 26 7f 59 26 66 72 26 4c 8c 26 33 a5 26 19 bf 26 00 00 00 00 00 00 b2 0c 3f 99 26 3f 7f 3f 3f 65 59 3f 4c 72 3f 32 8c 3f 19 a5 3f 00 00 00 00 00 00 00 00 00 99 0c 59 7f 26 59 65 3f 59 4c 59 59 33 72 59 19 8c 59 00 00 00 00 00 00 00 00 00 00 00 00 7f 0c 72 66 26 72 4c 3f 72 32 59 72 19 72 72 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 65 0c 8c 4c 26 8c 32 3f 8c 19 59 8c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 4c 0c a5 33 26 a5 19 3f a5 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 32 0c bf 19 26 bf 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 19 0c d8 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
        }
      }
      Framebuffer::depth = {
        Image::bytesPerPixel = 4
        Image::channels      = 1
        Image::pitch         = 40
        Image::format        = F32
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
      Framebuffer::stencil = {
        Image::bytesPerPixel = 1
        Image::channels      = 1
        Image::pitch         = 10
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
  }
  GPUMemory::programs[100] = {
    0:
      Program::fragmentShader = shader
      Program::vertexShader   = shader
      Program::vs2fs[0]   = VEC4 
      Program::vs2fs[1]   = EMPTY
      Program::vs2fs[2]   = EMPTY
      Program::vs2fs[3]   = EMPTY
  }
  GPUMemory::buffers[100] = {
    0:
      Buffer::data = vertexBuffer0
      Buffer::size = 48
    1:
      Buffer::data = vertexBuffer1
      Buffer::size = 48
  }
  GPUMemory::vertexArrays[10000] = {
    0:
      VertexArray::indexBufferID = -1
      VertexArray::indexOffset   = 0
      VertexArray::indexType     = U32
      VertexArray::vertexAttrib[0].bufferID = 0
      VertexArray::vertexAttrib[0].offset   = 0
      VertexArray::vertexAttrib[0].stride   = 16
      VertexArray::vertexAttrib[0].type     = VEC4 
      VertexArray::vertexAttrib[1].bufferID = 1
      VertexArray::vertexAttrib[1].offset   = 0
      VertexArray::vertexAttrib[1].stride   = 16
      VertexArray::vertexAttrib[1].type     = VEC4 
  }
[0m
  Jak√© zmƒõny byly nad pamƒõt√≠ provedeny je≈°tƒõ p≈ôed spu≈°tƒõn√≠m:
[1;90m  float vertexBuffer0[12] = {
    -1,    -1,    0,    1,    -1,    1,    0,    1,    1,    -1,    0,    1,
  };
  float vertexBuffer1[12] = {
    1,    0,    0,    1,    0,    0,    1,    1,    0,    1,    0,    1,
  };
  GPUMemory::framebuffers[10] = {
    0:
      Framebuffer::width     = 10
      Framebuffer::height    = 10
      Framebuffer::yReversed = 0
      Framebuffer::color = {
        Image::bytesPerPixel = 3
        Image::channels      = 3
        Image::pitch         = 30
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data[] = {00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 
        }
      }
      Framebuffer::depth = {
        Image::bytesPerPixel = 4
        Image::channels      = 1
        Image::pitch         = 40
        Image::format        = F32
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
      Framebuffer::stencil = {
        Image::bytesPerPixel = 1
        Image::channels      = 1
        Image::pitch         = 10
        Image::format        = U8 
        Image::channelTypes  = {RED  ,GREEN,BLUE ,ALPHA}
        Image::data = 0
      }
  }
  GPUMemory::programs[100] = {
    0:
      Program::fragmentShader = shader
      Program::vertexShader   = shader
      Program::vs2fs[0]   = VEC4 
      Program::vs2fs[1]   = EMPTY
      Program::vs2fs[2]   = EMPTY
      Program::vs2fs[3]   = EMPTY
  }
  GPUMemory::buffers[100] = {
    0:
      Buffer::data = vertexBuffer0
      Buffer::size = 48
    1:
      Buffer::data = vertexBuffer1
      Buffer::size = 48
  }
  GPUMemory::vertexArrays[10000] = {
    0:
      VertexArray::indexBufferID = -1
      VertexArray::indexOffset   = 0
      VertexArray::indexType     = U32
      VertexArray::vertexAttrib[0].bufferID = 0
      VertexArray::vertexAttrib[0].offset   = 0
      VertexArray::vertexAttrib[0].stride   = 16
      VertexArray::vertexAttrib[0].type     = VEC4 
      VertexArray::vertexAttrib[1].bufferID = 1
      VertexArray::vertexAttrib[1].offset   = 0
      VertexArray::vertexAttrib[1].stride   = 16
      VertexArray::vertexAttrib[1].type     = VEC4 
  }
[0m00 - clipping - CW triangle behind near plane
  raster test: 0 - ok.
00 - clipping - CCW triangle behind near plane
  raster test: 0 - ok.
00 - clipping - 1 vertex behind near plane
  raster test: 0 - ok.
00 - clipping - 2 vertices behind near plane
  raster test: 0 - ok.
00 - prepareModel - drawCommand - inserting roots
prepareModel p≈ôipravil CommandBuffer a GPUMemory ≈°patn√Ωm zp≈Øsobem:

  Tento test ovƒõ≈ôuje funkcionalitu funkce prepareModel.
  Je pot≈ôeba proj√≠t ko≈ôenov√© uzly (roots).
  Pokud nem√° uzel mesh (mesh<0), nevytv√°≈ô√≠ se pro nƒõj command buffer, proto≈æe nen√≠ co vykreslit.
  Je v≈°ak nut√© prozkoumat jeho potomky.
  Strom modelu by se mƒõly proj√≠t pre order p≈ô√≠stupem:
  https://en.wikipedia.org/wiki/Tree_traversal

  Nejsnaz≈°√≠ zpracov√°n√≠ je rekurz√≠, pseudok√≥d:

  void prepareNode(Node const&node){
    if(node.mesh>=0){
      //mame mesh vkladame do command bufferu
    }
    for(size_t i=0;i<node.children.size();++i)
      prepareNode(node.children[i]);
  }

  void prepare(Model const&model){
    for(size_t i=0;i<model.roots.size();++i)
      prepareNode(model.roots[i]);
  }

  Test zkou≈°√≠ zpracovat model, kter√Ω vypad√° takto:
  
  Model vypad√° takto:
  model{
    meshes  [0]
    roots   [1]
    textures[0]
  }
  root0{
    mesh = 0
    modelMatrix = (1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)
    children[0] = {}
  }

  A zkoum√°, jak√Ω jste vytvo≈ôili command bufferu a jak naplnili pamƒõt.
  Ale nƒõco se pokazilo...
Rozd√≠ln√Ω poƒçet p≈ô√≠kaz≈Ø v command bufferu!
V√°≈° poƒçet    : 0
Spr√°vn√Ω poƒçet: 3
V√°≈° command buffer obsahuje p≈ô√≠li≈° m√°lo p≈ô√≠kaz≈Ø!
Command s ƒç√≠slem: 0v√°m chyb√≠.
Command::type = BIND_VERTEXARRAY            
BindVertexArrayCommand::id = 0

V√°≈° command buffer obsahuje p≈ô√≠li≈° m√°lo p≈ô√≠kaz≈Ø!
Command s ƒç√≠slem: 1v√°m chyb√≠.
Command::type = SET_BACKFACE_CULLING_COMMAND
SetBackfaceCullingCommand::enabled = true

V√°≈° command buffer obsahuje p≈ô√≠li≈° m√°lo p≈ô√≠kaz≈Ø!
Command s ƒç√≠slem: 2v√°m chyb√≠.
Command::type = DRAW                        
DrawCommand::nofVertices = 3

mem.uniforms[102] = m4 = (1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);//va≈°e    
mem.uniforms[102] = m4 = (1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1);//mƒõlo b√Ωt
mem.uniforms[103] = m4 = (1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);//va≈°e    
mem.uniforms[103] = i4 = (-1,0,0,0);//mƒõlo b√Ωt
mem.uniforms[104] = m4 = (1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);//va≈°e    
mem.uniforms[104] = m4 = (0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);//mƒõlo b√Ωt

  Tento test ovƒõ≈ôuje funkcionalitu funkce prepareModel.

  Test zkou≈°√≠ zpracovat model s jednim meshem (3 vertexy) a jedn√≠m root bez potomk≈Ø.
  Model vypad√° takto:
  model{
    meshes  [0]
    roots   [1]
    textures[0]
  }
  root0{
    mesh = 0
    modelMatrix = (1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)
    children[0] = {}
  }

  Ale nƒõco se pokazilo...

  Model obsahuje polo≈æku roots.
  To jsou ko≈ôeny stromov√© struktury modelu.
  Polo≈æka roots je ulo≈æena ve std::vector.

  poƒçet roots se d√° zjistit pomoc√≠ roots.size().
  p≈ôistoupit k jednotliv√Ωch ko≈ôen≈Øm lze p≈ôes [] - roots[index].

  m≈Ø≈æete je proj√≠t t≈ôeba takto:
  for(size_t i=0;i<roots.size();++i){
    process(roots[i]...);
  }

  N√°povƒõda k implementaci drawModel:

  void prepareNode(GPUMemory&mem,CommandBuffer&cb,Node const&node,Model const&model,...){
    if(node.mesh >= 0){ // ma tento node mesh?
      Mesh const&mesh = model.meshes[node.mesh];

      addDrawCommand(cb,...);
      ...
      
    }
    ...
  }

  void prepareModel(GPUMemory&mem,CommandBuffer&cb,Model const&model){
    ...
    for(size_t i=0;i<model.roots.size();++i)
      prepareNode(mem,cb,model.roots[i],model,...);
  }
00 - prepareModel - drawCommand - mesh attributes & indexing
prepareModel p≈ôipravil CommandBuffer a GPUMemory ≈°patn√Ωm zp≈Øsobem:

  Tento test ovƒõ≈ôuje funkcionalitu funkce prepareModel.
  Je pot≈ôeba proj√≠t ko≈ôenov√© uzly (roots).
  Pokud nem√° uzel mesh (mesh<0), nevytv√°≈ô√≠ se pro nƒõj command buffer, proto≈æe nen√≠ co vykreslit.
  Je v≈°ak nut√© prozkoumat jeho potomky.
  Strom modelu by se mƒõly proj√≠t pre order p≈ô√≠stupem:
  https://en.wikipedia.org/wiki/Tree_traversal

  Nejsnaz≈°√≠ zpracov√°n√≠ je rekurz√≠, pseudok√≥d:

  void prepareNode(Node const&node){
    if(node.mesh>=0){
      //mame mesh vkladame do command bufferu
    }
    for(size_t i=0;i<node.children.size();++i)
      prepareNode(node.children[i]);
  }

  void prepare(Model const&model){
    for(size_t i=0;i<model.roots.size();++i)
      prepareNode(model.roots[i]);
  }

  Test zkou≈°√≠ zpracovat model, kter√Ω vypad√° takto:
  
  Model vypad√° takto:
  model{
    meshes  [0]
    roots   [1]
    textures[0]
  }
  root0{
    mesh = 0
    modelMatrix = (1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)
    children[0] = {}
  }

  A zkoum√°, jak√Ω jste vytvo≈ôili command bufferu a jak naplnili pamƒõt.
  Ale nƒõco se pokazilo...
Rozd√≠ln√Ω poƒçet p≈ô√≠kaz≈Ø v command bufferu!
V√°≈° poƒçet    : 0
Spr√°vn√Ω poƒçet: 3
V√°≈° command buffer obsahuje p≈ô√≠li≈° m√°lo p≈ô√≠kaz≈Ø!
Command s ƒç√≠slem: 0v√°m chyb√≠.
Command::type = BIND_VERTEXARRAY            
BindVertexArrayCommand::id = 0

V√°≈° command buffer obsahuje p≈ô√≠li≈° m√°lo p≈ô√≠kaz≈Ø!
Command s ƒç√≠slem: 1v√°m chyb√≠.
Command::type = SET_BACKFACE_CULLING_COMMAND
SetBackfaceCullingCommand::enabled = true

V√°≈° command buffer obsahuje p≈ô√≠li≈° m√°lo p≈ô√≠kaz≈Ø!
Command s ƒç√≠slem: 2v√°m chyb√≠.
Command::type = DRAW                        
DrawCommand::nofVertices = 3

mem.uniforms[102] = m4 = (1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);//va≈°e    
mem.uniforms[102] = m4 = (1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1);//mƒõlo b√Ωt
mem.uniforms[103] = m4 = (1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);//va≈°e    
mem.uniforms[103] = i4 = (-1,0,0,0);//mƒõlo b√Ωt
mem.uniforms[104] = m4 = (1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);//va≈°e    
mem.uniforms[104] = m4 = (0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);//mƒõlo b√Ωt
mem.vertexArrays[0].indexBufferID = -1;//va≈°e    
mem.vertexArrays[0].indexBufferID = 47;//mƒõlo b√Ωt
mem.vertexArrays[0].indexOffset = 0;//va≈°e    
mem.vertexArrays[0].indexOffset = 123;//mƒõlo b√Ωt
mem.vertexArrays[0].indexType = U32;//va≈°e    
mem.vertexArrays[0].indexType = U16;//mƒõlo b√Ωt
mem.vertexArrays[0].vertexAttrib[0].bufferID = -1;//va≈°e    
mem.vertexArrays[0].vertexAttrib[0].bufferID = 13;//mƒõlo b√Ωt
mem.vertexArrays[0].vertexAttrib[0].stride = 0;//va≈°e    
mem.vertexArrays[0].vertexAttrib[0].stride = 1334;//mƒõlo b√Ωt
mem.vertexArrays[0].vertexAttrib[0].offset = 0;//va≈°e    
mem.vertexArrays[0].vertexAttrib[0].offset = 32;//mƒõlo b√Ωt
mem.vertexArrays[0].vertexAttrib[0].type = EMPTY;//va≈°e    
mem.vertexArrays[0].vertexAttrib[0].type = VEC3 ;//mƒõlo b√Ωt
mem.vertexArrays[0].vertexAttrib[1].bufferID = -1;//va≈°e    
mem.vertexArrays[0].vertexAttrib[1].bufferID = 1;//mƒõlo b√Ωt
mem.vertexArrays[0].vertexAttrib[1].stride = 0;//va≈°e    
mem.vertexArrays[0].vertexAttrib[1].stride = 13;//mƒõlo b√Ωt
mem.vertexArrays[0].vertexAttrib[1].offset = 0;//va≈°e    
mem.vertexArrays[0].vertexAttrib[1].offset = 3423;//mƒõlo b√Ωt
mem.vertexArrays[0].vertexAttrib[1].type = EMPTY;//va≈°e    
mem.vertexArrays[0].vertexAttrib[1].type = VEC3 ;//mƒõlo b√Ωt
mem.vertexArrays[0].vertexAttrib[2].bufferID = -1;//va≈°e    
mem.vertexArrays[0].vertexAttrib[2].bufferID = 17;//mƒõlo b√Ωt
mem.vertexArrays[0].vertexAttrib[2].stride = 0;//va≈°e    
mem.vertexArrays[0].vertexAttrib[2].stride = 323;//mƒõlo b√Ωt
mem.vertexArrays[0].vertexAttrib[2].offset = 0;//va≈°e    
mem.vertexArrays[0].vertexAttrib[2].offset = 33;//mƒõlo b√Ωt
mem.vertexArrays[0].vertexAttrib[2].type = EMPTY;//va≈°e    
mem.vertexArrays[0].vertexAttrib[2].type = VEC2 ;//mƒõlo b√Ωt

  Tento test ovƒõ≈ôuje funkcionalitu funkce prepareModel.

  Test zkou≈°√≠ zpracovat model s jednim meshem (3 vertexy) a jedn√≠m root a bez potomk≈Ø.
  Test zkoum√°, jestli spr√°vnƒõ nastavujete attributy a indexing pro kreslen√≠.
  Konkr√©tnƒõ se jedn√° o nastaven√≠ VertexArray (vao).
  Pozice,normaly,tex coord. by mƒõly b√Ωt nastaven√© na 0., 1. a 2. attributu vao.
  
  Ale nƒõco se pokazilo...
00 - prepareModel - traverse - check roots
00 - prepareModel - traverse - node in node
00 - prepareModel - traverse - binary tree
00 - prepareModel - traverse - tree
00 - prepareModel - memory - shaders
00 - prepareModel - memory - vs2fs
00 - prepareModel - memory - buffers
00 - prepareModel - memory - textures
00 - prepareModel - uniforms - diffuse color
00 - prepareModel - uniforms - texture id
00 - prepareModel - uniforms - model matrix
00 - prepareModel - uniforms - inverse model matrix
00 - drawModel_vertexShader
00 - drawModel_fragmentShader - diffuse color
00 - drawModel_fragmentShader - ambient light
00 - drawModel_fragmentShader - diffuse light
00 - drawModel_fragmentShader - general tests

  P≈ô√≠znak discard mƒõl b√Ωt: outFrag.discard = true;
  Ale byl                : outFrag.discard = false;

  ===================================
  ======== Vstupn√≠ fragment =========
  ===================================

  Vstupn√≠ fragment je tvo≈ôen ƒçty≈ômi atributy:
   - pozice fragmentu ve world-space,
   - norm√°la ve world-space,
   - texturovac√≠ sou≈ôadnice fragmentu,
   - pozice fragmentu v clip-space st√≠nov√© mapy.

  inFragment.attributes[0].v3 = /* pozice                                                  */ (0,0,0);
  inFragment.attributes[1].v3 = /* normala                                                 */ (0,-1,0);
  inFragment.attributes[2].v2 = /* texturovaci sou≈ôadnice                                  */ (0.45,0.55);
  inFragment.attributes[3].v4 = /* pozice zobrazovan√©ho fragmentu v clip space shadow mapy */ (0.5,0.5,0.5,1);

  Shader ma p≈ô√≠stup k:
   - uniformn√≠m promƒõnn√Ωm,
   - textur√°m
   - ƒç√≠slu vykresovac√≠ho p≈ô√≠kazu.

  si.uniforms[getUniformLocation(drawID,LIGHT_POSITION     )].v3 = /* pozice svƒõtla                                                               */ (0,1,0); 
  si.uniforms[getUniformLocation(drawID,CAMERA_POSITION    )].v3 = /* pozice kamery                                                               */ (0,-1,0); 
  si.uniforms[getUniformLocation(drawID,SHADOWMAP_ID       )].i1 = /* ƒç√≠slo textury, kter√° obsahuje st√≠novou mapu, nebo -1 pokud st√≠ny nejsou     */ -1; 
  si.uniforms[getUniformLocation(drawID,AMBIENT_LIGHT_COLOR)].v3 = /* barva ambientn√≠ho svƒõtla                                                    */ (0.2,0.2,0.2); 
  si.uniforms[getUniformLocation(drawID,LIGHT_COLOR        )].v3 = /* barva svƒõtla                                                                */ (0,0,0); 
  si.uniforms[getUniformLocation(drawID,DIFFUSE_COLOR      )].v4 = /* difuzn√≠ barva materialu, - pokud nen√≠ textura                               */ (0.4,0.4,0.4,0.4); 
  si.uniforms[getUniformLocation(drawID,TEXTURE_ID         )].i1 = /* ƒç√≠slo textury s barvou nebo -1 pokud textura nen√≠.                          */ -1; 
  si.uniforms[getUniformLocation(drawID,DOUBLE_SIDED       )].v1 = /* 0.f znamen√°, ≈æe je to jednostran√Ω povrch, 1.f znamen√°, ≈æe je to doubleSided */ 0; 
  si.textures[] = {...}; // textury
  si.gl_DrawID  = 0    ; // ƒç√≠slo vykresovac√≠ho p≈ô√≠kazu - obvykle pro v√Ωbƒõr matic a materi√°l≈Ø
  


  ===================================
  ========== Obecn√© info ============
  ===================================

  Tento test zkou≈°√≠, zda je funkce drawModel_fragmentShader spr√°vnƒõ naimplementov√°na.
  Tato funkce reprezentuje fragment shader pro texturov√°n√≠, v√Ωpoƒçet osvƒõtlen√≠ a vrh√°n√≠ st√≠n≈Ø z model≈Ø.
  Fragment shader by mƒõl spoƒç√≠tat barvu pomoc√≠ lambertova osvƒõtlovac√≠ho modelu:
  https://en.wikipedia.org/wiki/Lambertian_reflectance
  A st√≠n pomoc√≠ shadow mappingu:
  https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping
  Vƒõt≈°ina shadow-mappingu u≈æ je udƒõl√°na, je jen pot≈ôeba st√≠novou mapu vyu≈æ√≠t.

  Vstupem FS je fragment a v√Ωstupem je fragment s vypoƒçtenou barvou.
  
  V√Ωstupn√≠ barva by mƒõla b√Ωt zaps√°na do promƒõnn√© outFragment.gl_FragColor.
  Pokud je nepr≈Øhlednost fragmentu p≈ô√≠li≈æ n√≠zka, shader by mƒõl nastavit p≈ô√≠znak discard.
  V takov√©m p≈ô√≠padƒõ na barvƒõ nez√°le≈æ√≠, proto≈æe se fragment stejnƒõ zahod√≠.

  Lambert≈Øv osvƒõtlovc√≠ model poƒç√≠t√° barvu ze dvou slo≈æek: ambientn√≠ a diffusn√≠.

  Ambietn√≠ slo≈æka je vypoƒç√≠t√°na jako souƒçin barvy materi√°lu a ambientn√≠ barvy svƒõtla:
  aL = dC * ambientLightColor; // souƒçin po komponent√°ch

  Difuzn√≠ slo≈æka je vypoƒç√≠t√°na jako souƒçin barvy materi√°lu s barvou svƒõtla
  vyn√°sobenou difuzn√≠m faktorem dF
  dL = dC * lightColor * dF;

  v√Ωsledn√° barva je:
  vec4(aL+dL,dC.a);

  dC je difuzn√≠ barva materi√°lu, je to buƒè hodnota z textury nebo z uniformn√≠ promƒõnn√©, kdy≈æ nen√≠ textura k dispozici.
  Pro ƒçten√≠ z textur pou≈æijte funkci read_texture(Texture const&tex,glm::vec2 const&coord);

  ambientLightColor je barva ambientn√≠ho svƒõtla.
  dF je difuzn√≠ faktor.
  Difuzn√≠ faktor je spoƒç√≠t√°n jako skal√°rn√≠ souƒçin vektoru
  z fragmentu do svƒõtla a norm√°ly fragmentu o≈ôezan√Ω do nez√°porn√Ωch hodnot.
  dF = glm::clamp(glm::dot(L,N),0.f,1.f)

  Pozor oba vektory mus√≠ b√Ωt normalizovan√©!
  pro normalizaci m≈Ø≈æete vyu≈æ√≠t funkci: glm::normalize()

  Pokud je zapnut√Ω p≈ô√≠znak doubleSided, je pot≈ôeba otoƒçit norm√°lu, pokud smƒõruje od kamery.
  Tzn. vektor od kamery k povrchu m√° stejn√Ω smƒõr jako norm√°la.

  dC.a je alpha - nepr≈Øhlednost

  Pokud je nepr≈Øhlednost < 0.5, mƒõl by se discard p≈ô√≠znak nastavit na true,
  t√≠m se fragment zahod√≠.

  Posledn√≠ vƒõc√≠, co by mƒõl shader ≈ôe≈°it je v√Ωpoƒçet st√≠nu.
  Ten je zaji≈°tƒõn tak, ≈æe pokud je fragment ve st√≠nu, v√Ωsledn√° barva je pouze d√°na ambientn√≠m osvƒõtlen√≠m (aL).

  Pro zji≈°tƒõn√≠, zda je fragment ve sn√≠mu je pot≈ôeba st√≠nov√© mapy.

  St√≠nov√° mapa je textura hloubky, kde je v ka≈æd√©m texelu vzd√°lenost k nejbli≈æ≈°√≠mu povrchu od svƒõtla.
  St√≠nov√° mapa (shadow mapa) m≈Ø≈æe a nemus√≠ b√Ωt vyu≈æ√≠v√°na.
  Pokud je ƒç√≠slo st√≠nov√© mapy -1, pak nen√≠ shadow-mapping vyu≈æit.
  V√Ωpoƒçet, jestli je st√≠n nebo ne je zaji≈°tƒõn porovn√°n√≠m vzd√°lenost fragmentu ke svƒõtlu
  a nejbli≈æ≈°√≠ vzd√°lenosti povrchu od svƒõtla.
  Pro zji≈°tƒõn√≠, kter√Ω texel st√≠nov√©, je pot≈ôeba pro porovn√°n√≠ pou≈æ√≠t, je pot≈ôeba
  z shadow mapu spr√°vnƒõ adresovat.
  K tomu je pot≈ôeba vyu≈æ√≠t sou≈ôadnici fragmentu v clip-space shadow mapy (4. atribut).
  shadowPosition.xyzw
  Ten je pot≈ôeba p≈ôev√©st do kart√©zk√Ωch sou≈ôadnic podƒõlen√≠m w.
  shadowPosition /= shadowPosition.w
  T√≠m vzniknou sou≈ôadnice do st√≠nov√© mapy v komponent√°ch x,y.

  Pozn√°mka: ty nejsou v rozsahu [-1,+1] jak jste zvykl√≠, ale v rozsahu [0,1].
  Je to zp≈Øsobeno tzn. bias matic√≠.

  V p≈ô√≠padƒõ, ≈æe osvƒõtlovan√Ω fragment padne mimo st√≠novou mapu < 0 || > 1,
  pak nele≈æ√≠ ve st√≠nu.
  St√≠nov√° mapa obecnƒõ nedok√°≈æe pokr√Ωt cel√Ω svƒõt, ale jen jeho podƒç√°st.

  Kdy≈æ se xy sou≈ôadnice pou≈æij√≠ pro vyƒçten√≠ hodnoty ze st√≠nov√© mapy pomoc√≠
  funkce read_texture, ƒçerven√Ω kan√°l obsahuje hloubku
  read_Texture(shadowMap, shadowPosition.xy).r

  Tu je pot≈ôeba porovnat se vzd√°lenost√≠ fragmentu od svƒõtla, co≈æ je
  3. (z) komponenta shadowPosition.
  if( shadowPosition.z < read_texture(...,...).r )
    st√≠n;

  Nƒõco se pokazilo...
00 - drawModel_fragmentShader - shadow mapping
00 - image to image comparison
  Fin√°ln√≠ obr√°zek se moc li≈°√≠ od reference!
  MSE je: 64.3609
  Akceptovateln√° chyba je: 40
